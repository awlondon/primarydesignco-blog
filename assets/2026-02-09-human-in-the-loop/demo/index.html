<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>PARTICLE FORGE</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Syne:wght@400;600;800&display=swap');

  :root {
    --bg: #080810;
    --panel: #0d0d1a;
    --panel2: #111122;
    --border: rgba(255,255,255,0.06);
    --accent: #7c5cfc;
    --accent2: #fc5c7d;
    --text: #e2e2f0;
    --muted: #5a5a7a;
    --success: #5cfca8;
    --mono: 'Space Mono', monospace;
    --display: 'Syne', sans-serif;
  }

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: var(--display);
    height: 100vh;
    overflow: hidden;
    cursor: crosshair;
  }

  #app {
    display: grid;
    grid-template-columns: 1fr 280px;
    height: 100vh;
  }

  #canvas-wrap {
    position: relative;
    overflow: hidden;
  }

  canvas {
    display: block;
    width: 100%;
    height: 100%;
  }

  /* Scanline overlay */
  #canvas-wrap::after {
    content: '';
    position: absolute;
    inset: 0;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(0,0,0,0.04) 2px,
      rgba(0,0,0,0.04) 4px
    );
    pointer-events: none;
    z-index: 2;
  }

  /* HUD overlays */
  #hud {
    position: absolute;
    inset: 0;
    pointer-events: none;
    z-index: 3;
  }

  #hud-tl, #hud-tr, #hud-bl, #hud-br {
    position: absolute;
    font-family: var(--mono);
    font-size: 10px;
    color: rgba(124,92,252,0.5);
    letter-spacing: 0.1em;
    line-height: 1.8;
  }
  #hud-tl { top: 18px; left: 20px; }
  #hud-tr { top: 18px; right: 20px; text-align: right; }
  #hud-bl { bottom: 18px; left: 20px; }
  #hud-br { bottom: 18px; right: 20px; text-align: right; }

  .corner-deco {
    position: absolute;
    width: 24px; height: 24px;
    pointer-events: none;
    z-index: 4;
  }
  .corner-deco::before, .corner-deco::after {
    content: '';
    position: absolute;
    background: var(--accent);
    opacity: 0.6;
  }
  .corner-deco::before { width: 100%; height: 1px; top: 0; left: 0; }
  .corner-deco::after  { width: 1px; height: 100%; top: 0; left: 0; }

  .c-tl { top: 10px; left: 10px; }
  .c-tr { top: 10px; right: 10px; transform: scaleX(-1); }
  .c-bl { bottom: 10px; left: 10px; transform: scaleY(-1); }
  .c-br { bottom: 10px; right: 10px; transform: scale(-1,-1); }

  /* Mouse burst indicator */
  #burst-ring {
    position: absolute;
    width: 40px; height: 40px;
    border: 1.5px solid var(--accent2);
    border-radius: 50%;
    pointer-events: none;
    transform: translate(-50%, -50%) scale(0);
    transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), opacity 0.3s;
    opacity: 0;
    z-index: 5;
  }
  #burst-ring.active {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
  }

  /* Side panel */
  #panel {
    background: var(--panel);
    border-left: 1px solid var(--border);
    overflow-y: auto;
    overflow-x: hidden;
    display: flex;
    flex-direction: column;
    scrollbar-width: thin;
    scrollbar-color: var(--accent) transparent;
  }
  #panel::-webkit-scrollbar { width: 3px; }
  #panel::-webkit-scrollbar-thumb { background: var(--accent); }

  .panel-header {
    padding: 20px 18px 14px;
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }
  .panel-title {
    font-size: 16px;
    font-weight: 800;
    letter-spacing: 0.25em;
    text-transform: uppercase;
    background: linear-gradient(90deg, var(--accent), var(--accent2));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  .panel-subtitle {
    font-family: var(--mono);
    font-size: 9px;
    color: var(--muted);
    letter-spacing: 0.12em;
    margin-top: 3px;
  }

  .section {
    padding: 12px 18px;
    border-bottom: 1px solid var(--border);
  }
  .section-label {
    font-family: var(--mono);
    font-size: 9px;
    font-weight: 700;
    letter-spacing: 0.18em;
    text-transform: uppercase;
    color: var(--muted);
    margin-bottom: 10px;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .section-label::after {
    content: '';
    flex: 1;
    height: 1px;
    background: var(--border);
  }

  /* Range inputs */
  .knob-row {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 10px;
  }
  .knob-label {
    font-family: var(--mono);
    font-size: 9px;
    color: var(--muted);
    width: 58px;
    flex-shrink: 0;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }
  .knob-val {
    font-family: var(--mono);
    font-size: 9px;
    color: var(--accent);
    width: 34px;
    text-align: right;
    flex-shrink: 0;
  }
  input[type=range] {
    -webkit-appearance: none;
    appearance: none;
    flex: 1;
    height: 2px;
    background: var(--panel2);
    border-radius: 2px;
    outline: none;
    border: none;
    cursor: pointer;
  }
  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 10px; height: 10px;
    border-radius: 50%;
    background: var(--accent);
    border: none;
    cursor: pointer;
    transition: transform 0.15s, box-shadow 0.15s;
    box-shadow: 0 0 6px var(--accent);
  }
  input[type=range]:hover::-webkit-slider-thumb {
    transform: scale(1.4);
    box-shadow: 0 0 12px var(--accent);
  }

  /* Select */
  select {
    width: 100%;
    background: var(--panel2);
    border: 1px solid var(--border);
    color: var(--text);
    font-family: var(--mono);
    font-size: 10px;
    padding: 6px 8px;
    border-radius: 4px;
    outline: none;
    cursor: pointer;
    appearance: none;
    -webkit-appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6' viewBox='0 0 10 6'%3E%3Cpath d='M0 0l5 6 5-6z' fill='%237c5cfc'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 8px center;
    padding-right: 24px;
    margin-bottom: 8px;
  }
  select:focus { border-color: var(--accent); }

  /* Color dual */
  .color-row {
    display: flex;
    gap: 8px;
    margin-bottom: 8px;
  }
  .color-cell {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }
  .color-cell span {
    font-family: var(--mono);
    font-size: 9px;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.08em;
  }
  input[type=color] {
    width: 100%;
    height: 26px;
    border: 1px solid var(--border);
    border-radius: 4px;
    background: none;
    cursor: pointer;
    padding: 2px;
  }

  /* Preset chips */
  .chip-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 5px;
    margin-bottom: 6px;
  }
  .chip {
    font-family: var(--mono);
    font-size: 9px;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    padding: 6px 4px;
    border: 1px solid var(--border);
    border-radius: 4px;
    background: var(--panel2);
    color: var(--muted);
    cursor: pointer;
    text-align: center;
    transition: all 0.15s;
  }
  .chip:hover {
    border-color: var(--accent);
    color: var(--accent);
    background: rgba(124,92,252,0.1);
  }
  .chip.active {
    border-color: var(--accent);
    color: var(--accent);
    background: rgba(124,92,252,0.15);
    box-shadow: 0 0 8px rgba(124,92,252,0.2);
  }

  /* Toggle buttons */
  .toggle-row {
    display: flex;
    gap: 5px;
    margin-bottom: 6px;
  }
  .toggle-btn {
    flex: 1;
    font-family: var(--mono);
    font-size: 9px;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    padding: 7px 4px;
    border: 1px solid var(--border);
    border-radius: 4px;
    background: var(--panel2);
    color: var(--muted);
    cursor: pointer;
    transition: all 0.15s;
    text-align: center;
  }
  .toggle-btn.on {
    border-color: var(--success);
    color: var(--success);
    background: rgba(92,252,168,0.08);
    box-shadow: 0 0 8px rgba(92,252,168,0.15);
  }
  .toggle-btn:not(.on):hover {
    border-color: var(--muted);
    color: var(--text);
  }

  /* Big buttons */
  .action-btn {
    width: 100%;
    font-family: var(--mono);
    font-size: 10px;
    letter-spacing: 0.14em;
    text-transform: uppercase;
    padding: 9px;
    border-radius: 4px;
    border: 1px solid;
    cursor: pointer;
    transition: all 0.15s;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    margin-bottom: 6px;
  }
  .action-btn.primary {
    border-color: var(--accent);
    background: rgba(124,92,252,0.1);
    color: var(--accent);
  }
  .action-btn.primary:hover {
    background: rgba(124,92,252,0.25);
    box-shadow: 0 0 16px rgba(124,92,252,0.3);
  }
  .action-btn.danger {
    border-color: var(--accent2);
    background: rgba(252,92,125,0.06);
    color: var(--accent2);
  }
  .action-btn.danger:hover {
    background: rgba(252,92,125,0.18);
  }

  /* Stats bar */
  #stats-panel {
    margin-top: auto;
    padding: 12px 18px;
    background: var(--panel2);
    border-top: 1px solid var(--border);
    flex-shrink: 0;
  }
  .stat-row {
    display: flex;
    justify-content: space-between;
    margin-bottom: 4px;
  }
  .stat-key {
    font-family: var(--mono);
    font-size: 9px;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.1em;
  }
  .stat-val {
    font-family: var(--mono);
    font-size: 9px;
    color: var(--accent);
  }

  /* Mode indicator */
  #mode-badge {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-family: var(--display);
    font-size: 64px;
    font-weight: 800;
    letter-spacing: 0.25em;
    text-transform: uppercase;
    color: rgba(124,92,252,0.04);
    pointer-events: none;
    z-index: 1;
    user-select: none;
    white-space: nowrap;
  }

  /* Bloom mode canvas needs a glow filter */
  .bloom canvas {
    filter: blur(0px) brightness(1.05);
  }

  /* Tooltip */
  .tip {
    font-family: var(--mono);
    font-size: 8px;
    color: rgba(90,90,122,0.8);
    margin-top: 4px;
    margin-bottom: 2px;
    font-style: italic;
  }
</style>
</head>
<body>
<div id="app">
  <div id="canvas-wrap">
    <canvas id="canvas"></canvas>
    <div id="burst-ring"></div>
    <div id="mode-badge">FORGE</div>

    <!-- Corner decorations -->
    <div class="corner-deco c-tl"></div>
    <div class="corner-deco c-tr"></div>
    <div class="corner-deco c-bl"></div>
    <div class="corner-deco c-br"></div>

    <!-- HUD -->
    <div id="hud">
      <div id="hud-tl">
        PARTICLE FORGE v2<br>
        <span id="hud-mode">MODE: AMBIENT</span>
      </div>
      <div id="hud-tr">
        FPS: <span id="fps">--</span><br>
        COUNT: <span id="count">--</span>
      </div>
      <div id="hud-bl">
        CLICK+DRAG → BURST<br>
        SCROLL → ZOOM SPEED
      </div>
      <div id="hud-br">
        <span id="hud-preset">PRESET: COSMIC</span>
      </div>
    </div>
  </div>

  <div id="panel">
    <div class="panel-header">
      <div class="panel-title">Particle Forge</div>
      <div class="panel-subtitle">REAL-TIME PARTICLE ENGINE · v2.0</div>
    </div>

    <!-- BEHAVIOR MODE -->
    <div class="section">
      <div class="section-label">Behavior Mode</div>
      <div class="chip-grid" id="mode-chips">
        <div class="chip active" data-mode="ambient">Ambient</div>
        <div class="chip" data-mode="explode">Explode</div>
        <div class="chip" data-mode="orbit">Orbit</div>
        <div class="chip" data-mode="vortex">Vortex</div>
        <div class="chip" data-mode="rain">Rain</div>
        <div class="chip" data-mode="repel">Repel</div>
        <div class="chip" data-mode="attract">Attract</div>
        <div class="chip" data-mode="swarm">Swarm</div>
      </div>
    </div>

    <!-- CORE PARAMS -->
    <div class="section">
      <div class="section-label">Core</div>
      <div class="knob-row">
        <span class="knob-label">Count</span>
        <input type="range" id="numParticles" min="10" max="3000" step="1" value="400">
        <span class="knob-val" id="numParticlesVal">400</span>
      </div>
      <div class="knob-row">
        <span class="knob-label">Speed</span>
        <input type="range" id="speed" min="0" max="12" step="0.1" value="2">
        <span class="knob-val" id="speedVal">2.0</span>
      </div>
      <div class="knob-row">
        <span class="knob-label">Size</span>
        <input type="range" id="size" min="0.5" max="14" step="0.5" value="3">
        <span class="knob-val" id="sizeVal">3.0</span>
      </div>
      <div class="knob-row">
        <span class="knob-label">Lifetime</span>
        <input type="range" id="lifetime" min="30" max="600" step="10" value="180">
        <span class="knob-val" id="lifetimeVal">180</span>
      </div>
    </div>

    <!-- PHYSICS -->
    <div class="section">
      <div class="section-label">Physics</div>
      <div class="knob-row">
        <span class="knob-label">Gravity</span>
        <input type="range" id="gravity" min="-0.3" max="0.3" step="0.01" value="0">
        <span class="knob-val" id="gravityVal">0.00</span>
      </div>
      <div class="knob-row">
        <span class="knob-label">Friction</span>
        <input type="range" id="friction" min="0.90" max="1.00" step="0.001" value="0.99">
        <span class="knob-val" id="frictionVal">0.990</span>
      </div>
      <div class="knob-row">
        <span class="knob-label">Turbulence</span>
        <input type="range" id="turbulence" min="0" max="0.5" step="0.01" value="0">
        <span class="knob-val" id="turbulenceVal">0.00</span>
      </div>
      <div class="knob-row">
        <span class="knob-label">Wind</span>
        <input type="range" id="wind" min="-0.1" max="0.1" step="0.005" value="0">
        <span class="knob-val" id="windVal">0.000</span>
      </div>
    </div>

    <!-- APPEARANCE -->
    <div class="section">
      <div class="section-label">Appearance</div>
      <select id="shape">
        <option value="circle" selected>● Circle</option>
        <option value="triangle">▲ Triangle</option>
        <option value="square">■ Square</option>
        <option value="star">★ Star</option>
        <option value="cross">✛ Cross</option>
        <option value="ring">○ Ring</option>
        <option value="spark">⁕ Spark</option>
      </select>
      <div class="knob-row">
        <span class="knob-label">Opacity</span>
        <input type="range" id="opacity" min="0.1" max="1" step="0.05" value="0.9">
        <span class="knob-val" id="opacityVal">0.90</span>
      </div>
      <div class="knob-row">
        <span class="knob-label">Glow</span>
        <input type="range" id="glow" min="0" max="20" step="0.5" value="4">
        <span class="knob-val" id="glowVal">4.0</span>
      </div>
      <div class="knob-row">
        <span class="knob-label">Trail</span>
        <input type="range" id="trail" min="0" max="0.98" step="0.01" value="0.12">
        <span class="knob-val" id="trailVal">0.12</span>
      </div>
    </div>

    <!-- COLOR -->
    <div class="section">
      <div class="section-label">Color</div>
      <div class="color-row">
        <div class="color-cell">
          <span>Start</span>
          <input type="color" id="colorStart" value="#7c5cfc">
        </div>
        <div class="color-cell">
          <span>Mid</span>
          <input type="color" id="colorMid" value="#fc5c7d">
        </div>
        <div class="color-cell">
          <span>End</span>
          <input type="color" id="colorEnd" value="#0a0820">
        </div>
      </div>
      <p class="tip">Color presets →</p>
      <div class="chip-grid" id="color-presets">
        <div class="chip" data-cs="#7c5cfc" data-cm="#fc5c7d" data-ce="#0a0820">Neon Dusk</div>
        <div class="chip" data-cs="#ff6f61" data-cm="#ffb347" data-ce="#2a0500">Inferno</div>
        <div class="chip" data-cs="#00fff2" data-cm="#0080ff" data-ce="#000c33">Cyber</div>
        <div class="chip" data-cs="#a8ff78" data-cm="#78ffd6" data-ce="#001a0d">Plasma</div>
        <div class="chip" data-cs="#ffecd2" data-cm="#fcb69f" data-ce="#330000">Peach</div>
        <div class="chip" data-cs="#e0c3fc" data-cm="#8ec5fc" data-ce="#0d0d2b">Aurora</div>
        <div class="chip" data-cs="#f9f047" data-cm="#0fd850" data-ce="#001100">Matrix</div>
        <div class="chip" data-cs="#ffffff" data-cm="#aaaacc" data-ce="#111122">Ghost</div>
      </div>
    </div>

    <!-- FEATURES -->
    <div class="section">
      <div class="section-label">Features</div>
      <div class="toggle-row">
        <button class="toggle-btn on" id="btn-trail">Trail</button>
        <button class="toggle-btn" id="btn-glow">Glow</button>
        <button class="toggle-btn" id="btn-wind">Wind</button>
      </div>
      <div class="toggle-row">
        <button class="toggle-btn" id="btn-connect">Connect</button>
        <button class="toggle-btn" id="btn-mouse">Mouse</button>
        <button class="toggle-btn" id="btn-pulse">Pulse</button>
      </div>
      <div class="knob-row" id="connect-dist-row" style="display:none">
        <span class="knob-label">Link Dist</span>
        <input type="range" id="connectDist" min="30" max="200" step="5" value="100">
        <span class="knob-val" id="connectDistVal">100</span>
      </div>
    </div>

    <!-- PRESETS -->
    <div class="section">
      <div class="section-label">Scene Presets</div>
      <div class="chip-grid" id="scene-presets">
        <div class="chip" data-scene="cosmic">Cosmic</div>
        <div class="chip" data-scene="fire">Fire</div>
        <div class="chip" data-scene="matrix">Matrix</div>
        <div class="chip" data-scene="aurora">Aurora</div>
        <div class="chip" data-scene="snow">Snow</div>
        <div class="chip" data-scene="vortex">Vortex</div>
      </div>
    </div>

    <!-- ACTIONS -->
    <div class="section">
      <div class="section-label">Actions</div>
      <button class="action-btn primary" id="btn-play">⏸ PAUSE</button>
      <button class="action-btn danger" id="btn-burst">⚡ BURST</button>
      <button class="action-btn primary" id="btn-reset" style="border-color:var(--muted);color:var(--muted);background:transparent">↺ RESET</button>
    </div>

    <div id="stats-panel">
      <div class="stat-row"><span class="stat-key">FPS</span><span class="stat-val" id="stat-fps">0</span></div>
      <div class="stat-row"><span class="stat-key">Particles</span><span class="stat-val" id="stat-count">0</span></div>
      <div class="stat-row"><span class="stat-key">Mode</span><span class="stat-val" id="stat-mode">ambient</span></div>
      <div class="stat-row"><span class="stat-key">Time</span><span class="stat-val" id="stat-time">0s</span></div>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const wrap = document.getElementById('canvas-wrap');

  let W, H;
  function resize() {
    const rect = wrap.getBoundingClientRect();
    W = rect.width;
    H = rect.height;
    canvas.width = Math.round(W * devicePixelRatio);
    canvas.height = Math.round(H * devicePixelRatio);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
  }
  window.addEventListener('resize', () => { resize(); recreate(); });
  resize();

  // ---------- STATE ----------
  let state = {
    count: 400,
    speed: 2,
    size: 3,
    lifetime: 180,
    gravity: 0,
    friction: 0.99,
    turbulence: 0,
    wind: 0,
    opacity: 0.9,
    glow: 4,
    trailAlpha: 0.12,
    shape: 'circle',
    colorStart: '#7c5cfc',
    colorMid: '#fc5c7d',
    colorEnd: '#0a0820',
    connectDist: 100,
    mode: 'ambient',
    trail: true,
    glowEnabled: false,
    windEnabled: false,
    connectEnabled: false,
    mouseEnabled: false,
    pulseEnabled: false,
    running: true,
  };

  let particles = [];
  let mouseX = W / 2, mouseY = H / 2;
  let mouseDown = false;
  let startTime = performance.now();
  let elapsed = 0;

  // ---------- COLOR UTILITIES ----------
  function hexToRgb(hex) {
    const r = parseInt(hex.slice(1,3),16);
    const g = parseInt(hex.slice(3,5),16);
    const b = parseInt(hex.slice(5,7),16);
    return [r,g,b];
  }

  function lerpColor3(c0, c1, c2, t) {
    const [r0,g0,b0] = hexToRgb(c0);
    const [r1,g1,b1] = hexToRgb(c1);
    const [r2,g2,b2] = hexToRgb(c2);
    let r, g, b;
    if (t < 0.5) {
      const s = t * 2;
      r = Math.round(r0 + (r1-r0)*s);
      g = Math.round(g0 + (g1-g0)*s);
      b = Math.round(b0 + (b1-b0)*s);
    } else {
      const s = (t - 0.5) * 2;
      r = Math.round(r1 + (r2-r1)*s);
      g = Math.round(g1 + (g2-g1)*s);
      b = Math.round(b1 + (b2-b1)*s);
    }
    return [r, g, b];
  }

  // ---------- SHAPES ----------
  function drawShape(ctx, shape, x, y, r) {
    ctx.beginPath();
    switch(shape) {
      case 'circle':
        ctx.arc(x, y, r, 0, Math.PI*2);
        ctx.fill();
        break;
      case 'square':
        ctx.rect(x-r, y-r, r*2, r*2);
        ctx.fill();
        break;
      case 'triangle':
        ctx.moveTo(x, y-r);
        ctx.lineTo(x + r*Math.sin(2*Math.PI/3), y-r*Math.cos(2*Math.PI/3));
        ctx.lineTo(x - r*Math.sin(2*Math.PI/3), y-r*Math.cos(2*Math.PI/3));
        ctx.closePath();
        ctx.fill();
        break;
      case 'star': {
        const s=5, outer=r, inner=r/2.5;
        let rot = -Math.PI/2;
        for(let i=0;i<s*2;i++){
          const rad = i%2===0 ? outer : inner;
          i===0 ? ctx.moveTo(x+Math.cos(rot)*rad, y+Math.sin(rot)*rad)
                : ctx.lineTo(x+Math.cos(rot)*rad, y+Math.sin(rot)*rad);
          rot += Math.PI/s;
        }
        ctx.closePath();
        ctx.fill();
        break;
      }
      case 'cross': {
        const t = r*0.35;
        ctx.rect(x-t, y-r, t*2, r*2);
        ctx.fill();
        ctx.beginPath();
        ctx.rect(x-r, y-t, r*2, t*2);
        ctx.fill();
        break;
      }
      case 'ring':
        ctx.arc(x, y, r, 0, Math.PI*2);
        ctx.strokeStyle = ctx.fillStyle;
        ctx.lineWidth = r * 0.3;
        ctx.stroke();
        break;
      case 'spark': {
        const spikes = 4, len = r*1.2, thinLen = r*0.4;
        for(let i=0;i<8;i++){
          const angle = (Math.PI/4)*i;
          const rr = i%2===0 ? len : thinLen;
          i===0 ? ctx.moveTo(x,y) : null;
          ctx.lineTo(x+Math.cos(angle)*rr, y+Math.sin(angle)*rr);
          ctx.lineTo(x,y);
        }
        ctx.closePath();
        ctx.fill();
        break;
      }
      default:
        ctx.arc(x, y, r, 0, Math.PI*2);
        ctx.fill();
    }
  }

  // ---------- NOISE (simple perlin-like) ----------
  const permTable = new Uint8Array(512);
  for(let i=0;i<256;i++) permTable[i] = permTable[i+256] = Math.floor(Math.random()*256);
  function noise2d(x, y) {
    const X = Math.floor(x)&255, Y = Math.floor(y)&255;
    x -= Math.floor(x); y -= Math.floor(y);
    const fade = t => t*t*t*(t*(t*6-15)+10);
    const lerp = (a,b,t) => a + t*(b-a);
    const grad = (h,x,y) => { const v=h&3; return (v<2?x:-x)+(v===1||v===2?y:-y); };
    const aa = permTable[permTable[X]+Y], ab = permTable[permTable[X]+Y+1];
    const ba = permTable[permTable[X+1]+Y], bb = permTable[permTable[X+1]+Y+1];
    const u = fade(x), v = fade(y);
    return lerp(lerp(grad(aa,x,y),grad(ba,x-1,y),u),lerp(grad(ab,x,y-1),grad(bb,x-1,y-1),u),v);
  }

  // ---------- PARTICLE CLASS ----------
  class Particle {
    constructor(px, py) {
      this.init(px, py);
    }

    init(px, py) {
      const m = state.mode;
      this.x = px !== undefined ? px : Math.random() * W;
      this.y = py !== undefined ? py : Math.random() * H;

      if (m === 'explode') {
        const a = Math.random() * Math.PI * 2;
        const sp = (0.3 + Math.random()*1) * state.speed * 3;
        this.vx = Math.cos(a) * sp;
        this.vy = Math.sin(a) * sp;
      } else if (m === 'orbit') {
        const a = Math.random() * Math.PI * 2;
        const sp = state.speed * 0.8;
        this.vx = -Math.sin(a) * sp;
        this.vy =  Math.cos(a) * sp;
      } else if (m === 'vortex') {
        const a = Math.random() * Math.PI * 2;
        const sp = state.speed * 1.2;
        this.vx = -Math.sin(a) * sp;
        this.vy =  Math.cos(a) * sp;
      } else if (m === 'rain') {
        this.x = Math.random() * W;
        this.y = -20;
        this.vx = (Math.random()-0.5) * state.speed * 0.5;
        this.vy = state.speed * (1.5 + Math.random());
      } else if (m === 'repel' || m === 'attract') {
        const a = Math.random() * Math.PI * 2;
        const sp = state.speed * 0.5;
        this.vx = Math.cos(a) * sp;
        this.vy = Math.sin(a) * sp;
      } else if (m === 'swarm') {
        const a = Math.random() * Math.PI * 2;
        this.vx = Math.cos(a) * state.speed * 0.3;
        this.vy = Math.sin(a) * state.speed * 0.3;
      } else {
        const a = Math.random() * Math.PI * 2;
        const sp = state.speed * (0.4 + Math.random() * 0.6);
        this.vx = Math.cos(a) * sp;
        this.vy = Math.sin(a) * sp;
      }

      const base = state.size;
      this.size = base * (0.5 + Math.random() * 1.0);
      this.maxLife = state.lifetime * (0.7 + Math.random() * 0.6);
      this.age = Math.random() * this.maxLife;
      this.rotation = Math.random() * Math.PI * 2;
      this.rotSpeed = (Math.random()-0.5) * 0.04;
      this.noiseOff = Math.random() * 100;
    }

    update(t) {
      this.age++;
      if (this.age >= this.maxLife) {
        this.init();
        return;
      }

      const m = state.mode;
      const cx = W/2, cy = H/2;

      // Turbulence via noise
      if (state.turbulence > 0) {
        const nScale = 0.003;
        const nx = noise2d((this.x + this.noiseOff) * nScale, t * 0.001);
        const ny = noise2d((this.y + this.noiseOff + 50) * nScale, t * 0.001 + 50);
        this.vx += nx * state.turbulence * 0.4;
        this.vy += ny * state.turbulence * 0.4;
      }

      // Mode-specific forces
      if (m === 'orbit') {
        const dx = this.x - cx, dy = this.y - cy;
        const dist = Math.sqrt(dx*dx+dy*dy) || 1;
        const force = 0.015 * state.speed;
        this.vx -= dy/dist * force;
        this.vy += dx/dist * force;
        const attraction = 0.001 * state.speed;
        this.vx -= dx/dist * attraction;
        this.vy -= dy/dist * attraction;
      } else if (m === 'vortex') {
        const dx = this.x - cx, dy = this.y - cy;
        const dist = Math.sqrt(dx*dx+dy*dy) || 1;
        const tangent = 0.02 * state.speed;
        const inward = 0.003 * state.speed;
        this.vx += (-dy/dist * tangent - dx/dist * inward);
        this.vy += ( dx/dist * tangent - dy/dist * inward);
      } else if (m === 'repel' && state.mouseEnabled) {
        const dx = this.x - mouseX, dy = this.y - mouseY;
        const dist2 = dx*dx + dy*dy;
        if (dist2 < 10000) {
          const d = Math.sqrt(dist2) || 1;
          const f = (100/d) * 0.08 * state.speed;
          this.vx += dx/d * f;
          this.vy += dy/d * f;
        }
      } else if (m === 'attract' && state.mouseEnabled) {
        const dx = mouseX - this.x, dy = mouseY - this.y;
        const dist2 = dx*dx + dy*dy;
        if (dist2 < 40000 && dist2 > 400) {
          const d = Math.sqrt(dist2) || 1;
          const f = 0.04 * state.speed;
          this.vx += dx/d * f;
          this.vy += dy/d * f;
        }
      } else if (m === 'swarm') {
        const dx = mouseX - this.x, dy = mouseY - this.y;
        const d = Math.sqrt(dx*dx+dy*dy) || 1;
        const f = 0.02 * state.speed;
        this.vx += dx/d * f * 0.5;
        this.vy += dy/d * f * 0.5;
        this.vx += (Math.random()-0.5) * 0.1;
        this.vy += (Math.random()-0.5) * 0.1;
      } else if (m === 'rain') {
        this.vy += 0.15;
      } else if (m === 'repel' || m === 'attract') {
        // without mouse - just float
      }

      // Pulse: oscillating size
      if (state.pulseEnabled) {
        this._pulseT = (this._pulseT || this.noiseOff) + 0.04;
        this._displaySize = this.size * (0.6 + 0.5 * Math.abs(Math.sin(this._pulseT)));
      }

      // Global forces
      this.vy += state.gravity;
      const fw = state.windEnabled ? (Math.sin(t/800)*state.wind*0.5 + state.wind) : 0;
      this.vx += fw;

      // Friction
      this.vx *= state.friction;
      this.vy *= state.friction;

      // Clamp velocity
      const maxV = state.speed * 4;
      const spd = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
      if (spd > maxV) { this.vx = this.vx/spd*maxV; this.vy = this.vy/spd*maxV; }

      this.x += this.vx;
      this.y += this.vy;
      this.rotation += this.rotSpeed;

      // Boundary
      if (m === 'rain') {
        if (this.y > H + 20) { this.x = Math.random()*W; this.y = -20; this.vy = state.speed*(1.5+Math.random()); this.age=0; }
        if (this.x < -20) this.x = W+20;
        if (this.x > W+20) this.x = -20;
      } else {
        const margin = this.size + 5;
        if (this.x < -margin) this.x = W + margin;
        else if (this.x > W + margin) this.x = -margin;
        if (this.y < -margin) this.y = H + margin;
        else if (this.y > H + margin) this.y = -margin;
      }
    }

    draw(ctx, t) {
      const lifeT = this.age / this.maxLife;
      const [r,g,b] = lerpColor3(state.colorStart, state.colorMid, state.colorEnd, lifeT);

      let alpha = state.opacity;
      // Fade in and out
      if (lifeT < 0.1) alpha *= lifeT / 0.1;
      else if (lifeT > 0.85) alpha *= (1 - lifeT) / 0.15;

      const drawSize = state.pulseEnabled ? (this._displaySize || this.size) : this.size;

      // Glow
      if (state.glowEnabled && state.glow > 0) {
        ctx.shadowBlur = state.glow * 2;
        ctx.shadowColor = `rgba(${r},${g},${b},${alpha * 0.8})`;
      } else {
        ctx.shadowBlur = 0;
      }

      ctx.fillStyle = `rgba(${r},${g},${b},${alpha})`;
      ctx.strokeStyle = `rgba(${r},${g},${b},${alpha})`;

      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.rotation);
      drawShape(ctx, state.shape, 0, 0, drawSize);
      ctx.restore();
    }
  }

  // ---------- BURST EMITTER ----------
  function burst(x, y, count = 80) {
    for (let i = 0; i < count; i++) {
      const p = new Particle(x, y);
      const a = Math.random() * Math.PI * 2;
      const sp = state.speed * (1 + Math.random() * 4);
      p.vx = Math.cos(a) * sp;
      p.vy = Math.sin(a) * sp;
      p.age = 0;
      p.maxLife = 60 + Math.random() * 80;
      particles.push(p);
    }
    // Remove oldest to stay near count
    while (particles.length > state.count + 200) particles.shift();
  }

  // ---------- PARTICLE RECREATION ----------
  function recreate() {
    particles = [];
    for (let i = 0; i < state.count; i++) {
      particles.push(new Particle());
    }
  }
  recreate();

  // ---------- CONNECT LINES ----------
  function drawConnections() {
    if (!state.connectEnabled) return;
    const dist = state.connectDist;
    const dist2 = dist * dist;
    ctx.lineWidth = 0.5;
    for (let i = 0; i < particles.length; i++) {
      for (let j = i + 1; j < particles.length; j++) {
        const dx = particles[i].x - particles[j].x;
        const dy = particles[i].y - particles[j].y;
        const d2 = dx*dx + dy*dy;
        if (d2 < dist2) {
          const alpha = (1 - Math.sqrt(d2)/dist) * 0.4;
          const lifeT = particles[i].age / particles[i].maxLife;
          const [r,g,b] = lerpColor3(state.colorStart, state.colorMid, state.colorEnd, lifeT);
          ctx.beginPath();
          ctx.strokeStyle = `rgba(${r},${g},${b},${alpha})`;
          ctx.moveTo(particles[i].x, particles[i].y);
          ctx.lineTo(particles[j].x, particles[j].y);
          ctx.stroke();
        }
      }
    }
  }

  // ---------- MOUSE INTERACTIONS ----------
  let mouseTimer = null;
  const burstRing = document.getElementById('burst-ring');

  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;
    burstRing.style.left = e.clientX + 'px';
    burstRing.style.top = e.clientY + 'px';
  });

  canvas.addEventListener('mousedown', (e) => {
    mouseDown = true;
    burstRing.classList.add('active');
    const rect = canvas.getBoundingClientRect();
    burst(e.clientX - rect.left, e.clientY - rect.top, 60);
  });

  canvas.addEventListener('mouseup', () => {
    mouseDown = false;
    burstRing.classList.remove('active');
  });

  canvas.addEventListener('mouseleave', () => {
    mouseDown = false;
    burstRing.classList.remove('active');
  });

  canvas.addEventListener('mousemove', (e) => {
    if (!mouseDown) return;
    const rect = canvas.getBoundingClientRect();
    if (Math.random() < 0.3) burst(e.clientX - rect.left, e.clientY - rect.top, 8);
  });

  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    state.speed = Math.max(0, Math.min(12, state.speed - e.deltaY * 0.005));
    document.getElementById('speed').value = state.speed;
    document.getElementById('speedVal').textContent = state.speed.toFixed(1);
  }, { passive: false });

  // ---------- RENDER LOOP ----------
  let lastT = performance.now();
  let fpsFrames = 0;
  let fpsSample = performance.now();
  let displayFPS = 0;

  function render(t) {
    if (!state.running) return;
    requestAnimationFrame(render);

    fpsFrames++;
    if (t - fpsSample > 500) {
      displayFPS = Math.round(fpsFrames * 1000 / (t - fpsSample));
      fpsSample = t;
      fpsFrames = 0;
      document.getElementById('fps').textContent = displayFPS;
      document.getElementById('stat-fps').textContent = displayFPS;
      document.getElementById('count').textContent = particles.length;
      document.getElementById('stat-count').textContent = particles.length;
      elapsed = Math.round((t - startTime) / 1000);
      document.getElementById('stat-time').textContent = elapsed + 's';
    }

    // Background / trail
    if (state.trail && state.trailAlpha < 1) {
      ctx.fillStyle = `rgba(8,8,16,${1 - state.trailAlpha})`;
      ctx.fillRect(0, 0, W, H);
    } else {
      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = '#080810';
      ctx.fillRect(0, 0, W, H);
    }

    // Draw connections first (behind particles)
    drawConnections();

    // Update + draw particles
    for (const p of particles) {
      p.update(t);
      p.draw(ctx, t);
    }

    ctx.shadowBlur = 0;
    lastT = t;
  }
  requestAnimationFrame(render);

  // ---------- UI HELPERS ----------
  function syncKnob(id, stateKey, valId, format) {
    const el = document.getElementById(id);
    const valEl = document.getElementById(valId);
    el.addEventListener('input', () => {
      state[stateKey] = parseFloat(el.value);
      valEl.textContent = typeof format === 'function' ? format(state[stateKey]) : state[stateKey];
      if (stateKey === 'count') recreate();
    });
  }

  syncKnob('numParticles', 'count', 'numParticlesVal', v => Math.round(v));
  syncKnob('speed', 'speed', 'speedVal', v => v.toFixed(1));
  syncKnob('size', 'size', 'sizeVal', v => v.toFixed(1));
  syncKnob('lifetime', 'lifetime', 'lifetimeVal', v => Math.round(v));
  syncKnob('gravity', 'gravity', 'gravityVal', v => v.toFixed(2));
  syncKnob('friction', 'friction', 'frictionVal', v => v.toFixed(3));
  syncKnob('turbulence', 'turbulence', 'turbulenceVal', v => v.toFixed(2));
  syncKnob('wind', 'wind', 'windVal', v => v.toFixed(3));
  syncKnob('opacity', 'opacity', 'opacityVal', v => v.toFixed(2));
  syncKnob('glow', 'glow', 'glowVal', v => v.toFixed(1));
  syncKnob('trail', 'trailAlpha', 'trailVal', v => v.toFixed(2));
  syncKnob('connectDist', 'connectDist', 'connectDistVal', v => Math.round(v));

  document.getElementById('shape').addEventListener('change', e => {
    state.shape = e.target.value;
  });

  ['colorStart','colorMid','colorEnd'].forEach(id => {
    document.getElementById(id).addEventListener('input', e => {
      state[id] = e.target.value;
    });
  });

  // Mode chips
  document.getElementById('mode-chips').querySelectorAll('.chip').forEach(chip => {
    chip.addEventListener('click', () => {
      document.querySelectorAll('#mode-chips .chip').forEach(c => c.classList.remove('active'));
      chip.classList.add('active');
      state.mode = chip.dataset.mode;
      document.getElementById('hud-mode').textContent = 'MODE: ' + state.mode.toUpperCase();
      document.getElementById('stat-mode').textContent = state.mode;
      recreate();
    });
  });

  // Color presets
  document.getElementById('color-presets').querySelectorAll('.chip').forEach(chip => {
    chip.addEventListener('click', () => {
      state.colorStart = chip.dataset.cs;
      state.colorMid = chip.dataset.cm;
      state.colorEnd = chip.dataset.ce;
      document.getElementById('colorStart').value = state.colorStart;
      document.getElementById('colorMid').value = state.colorMid;
      document.getElementById('colorEnd').value = state.colorEnd;
    });
  });

  // Scene presets
  const scenes = {
    cosmic:  { mode:'orbit',   count:500, speed:1.5, size:2.5, gravity:0, turbulence:0.05, cs:'#c1e1ec',  cm:'#8065dd', ce:'#0c2340',  shape:'star',   trailAlpha:0.08, glowEnabled:true,  glow:8  },
    fire:    { mode:'ambient', count:600, speed:4,   size:3,   gravity:-0.08, turbulence:0.2, cs:'#ffe599', cm:'#ff4500', ce:'#220000',  shape:'spark',  trailAlpha:0.2,  glowEnabled:true,  glow:12 },
    matrix:  { mode:'rain',    count:300, speed:5,   size:2,   gravity:0,  turbulence:0, cs:'#00ff66',  cm:'#00aa44', ce:'#001100',  shape:'square', trailAlpha:0.08, glowEnabled:true,  glow:4  },
    aurora:  { mode:'vortex',  count:700, speed:1,   size:4,   gravity:0,  turbulence:0.1, cs:'#e0c3fc', cm:'#a8edea', ce:'#0a0820',  shape:'circle', trailAlpha:0.05, glowEnabled:true,  glow:14 },
    snow:    { mode:'ambient', count:400, speed:1.5, size:3,   gravity:0.03, turbulence:0.05, cs:'#ffffff', cm:'#aaccff', ce:'#112244', shape:'circle', trailAlpha:0.3,  glowEnabled:false, glow:2  },
    vortex:  { mode:'vortex',  count:800, speed:3,   size:2,   gravity:0,  turbulence:0.15, cs:'#7c5cfc', cm:'#fc5c7d', ce:'#0a0820',  shape:'triangle',trailAlpha:0.06, glowEnabled:true, glow:10 },
  };

  document.getElementById('scene-presets').querySelectorAll('.chip').forEach(chip => {
    chip.addEventListener('click', () => {
      const s = scenes[chip.dataset.scene];
      if (!s) return;
      Object.assign(state, s);
      // Update UI
      document.getElementById('numParticles').value = s.count;
      document.getElementById('numParticlesVal').textContent = s.count;
      document.getElementById('speed').value = s.speed;
      document.getElementById('speedVal').textContent = s.speed.toFixed(1);
      document.getElementById('size').value = s.size;
      document.getElementById('sizeVal').textContent = s.size.toFixed(1);
      document.getElementById('gravity').value = s.gravity;
      document.getElementById('gravityVal').textContent = s.gravity.toFixed(2);
      document.getElementById('turbulence').value = s.turbulence;
      document.getElementById('turbulenceVal').textContent = s.turbulence.toFixed(2);
      document.getElementById('trail').value = s.trailAlpha;
      document.getElementById('trailVal').textContent = s.trailAlpha.toFixed(2);
      document.getElementById('glow').value = s.glow;
      document.getElementById('glowVal').textContent = s.glow.toFixed(1);
      document.getElementById('colorStart').value = s.cs;
      document.getElementById('colorMid').value = s.cm;
      document.getElementById('colorEnd').value = s.ce;
      document.getElementById('shape').value = s.shape;
      state.colorStart = s.cs; state.colorMid = s.cm; state.colorEnd = s.ce;
      document.getElementById('stat-mode').textContent = s.mode;

      // Update glow toggle
      const glowBtn = document.getElementById('btn-glow');
      glowBtn.classList.toggle('on', s.glowEnabled);
      glowBtn.textContent = 'Glow';

      // Update mode chips
      document.querySelectorAll('#mode-chips .chip').forEach(c => {
        c.classList.toggle('active', c.dataset.mode === s.mode);
      });

      document.getElementById('hud-mode').textContent = 'MODE: ' + s.mode.toUpperCase();
      document.getElementById('hud-preset').textContent = 'PRESET: ' + chip.dataset.scene.toUpperCase();
      recreate();
    });
  });

  // Toggle buttons
  function makeToggle(btnId, stateKey, extraRow) {
    const btn = document.getElementById(btnId);
    btn.addEventListener('click', () => {
      state[stateKey] = !state[stateKey];
      btn.classList.toggle('on', state[stateKey]);
      if (extraRow) {
        document.getElementById(extraRow).style.display = state[stateKey] ? 'flex' : 'none';
      }
    });
  }
  makeToggle('btn-trail', 'trail');
  makeToggle('btn-glow', 'glowEnabled');
  makeToggle('btn-wind', 'windEnabled');
  makeToggle('btn-connect', 'connectEnabled', 'connect-dist-row');
  makeToggle('btn-mouse', 'mouseEnabled');
  makeToggle('btn-pulse', 'pulseEnabled');

  // Action buttons
  document.getElementById('btn-play').addEventListener('click', () => {
    state.running = !state.running;
    const btn = document.getElementById('btn-play');
    btn.textContent = state.running ? '⏸ PAUSE' : '▶ PLAY';
    if (state.running) {
      lastT = performance.now();
      requestAnimationFrame(render);
    }
  });

  document.getElementById('btn-burst').addEventListener('click', () => {
    burst(W/2, H/2, 150);
  });

  document.getElementById('btn-reset').addEventListener('click', () => {
    recreate();
  });

  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    if (e.key === ' ') { e.preventDefault(); document.getElementById('btn-play').click(); }
    if (e.key === 'b') burst(W/2, H/2, 120);
    if (e.key === 'r') recreate();
  });
})();
</script>
</body>
</html>
<-- OLD VERSION FROM PDCO DEV STUDIO
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Sophisticated Particle Generator</title>
<style>
  body,html {
    margin:0; padding:0; height:100%; overflow:hidden; background:#111;
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    color:#eee;
    user-select:none;
  }
  #app {
    height:100vh;
    display: flex;
    flex-direction: row;
  }
  #canvas {
    flex: 1;
    background: radial-gradient(circle at center, #222 0%, #111 90%);
    display: block;
  }
  #controls {
    width: 300px;
    background: #161616;
    padding: 20px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
  }
  #controls h2 {
    margin: 0 0 15px;
    font-weight: 600;
    color: #75c7ff;
    text-align: center;
  }
  label {
    font-size: 0.9rem;
    margin-top: 10px;
  }
  input[type=range], input[type=color], select {
    width: 100%;
    margin-top: 5px;
  }
  #stats {
    margin-top: auto;
    font-size: 0.85rem;
    color: #aaa;
    background: #222;
    padding: 10px;
    border-radius: 8px;
    text-align:center;
    user-select:none;
  }
  button, .preset-btn {
    margin-top: 10px;
    background: #2471ff;
    border:none;
    padding: 8px;
    color: white;
    font-weight: 600;
    border-radius: 6px;
    cursor:pointer;
    transition: background 0.3s;
  }
  button:hover, .preset-btn:hover {
    background: #4a90ff;
  }
  .preset-container {
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
    margin-top: 10px;
    justify-content: center;
  }
  .preset-btn {
    flex: 1 0 48%;
    font-size: 0.8rem;
    padding: 6px 4px;
  }
  small {
    color: #666;
  }
</style>
</head>
<body>
<div id="app">
  <canvas id="canvas"></canvas>
  <div id="controls">
    <h2>Particles Control</h2>

    <label for="presetCategory">Preset Category</label>
    <select id="presetCategory">
      <option value="basic" selected>Basic</option>
      <option value="fireworks">Fireworks</option>
      <option value="space">Space</option>
      <option value="nature">Nature</option>
    </select>

    <label>Preset Selection</label>
    <div class="preset-container" id="presetSelection"></div>

    <label for="numParticles">Number of Particles <small>(max 1000)</small></label>
    <input type="range" id="numParticles" min="10" max="1000" step="1" value="300" />

    <label for="speed">Speed <small>(px/frame)</small></label>
    <input type="range" id="speed" min="0" max="10" step="0.1" value="2" />

    <label for="size">Particle Size <small>(px radius)</small></label>
    <input type="range" id="size" min="1" max="10" step="0.5" value="4" />

    <label for="shape">Shape</label>
    <select id="shape">
      <option value="circle" selected>Circle</option>
      <option value="triangle">Triangle</option>
      <option value="square">Square</option>
      <option value="star">Star</option>
    </select>

    <label for="colorStart">Color Start</label>
    <input type="color" id="colorStart" value="#75c7ff" />

    <label for="colorEnd">Color End</label>
    <input type="color" id="colorEnd" value="#1a1a1a" />

    <label for="gravity">Gravity</label>
    <input type="range" id="gravity" min="-0.2" max="0.2" step="0.01" value="0" />

    <div style="margin-top:10px; text-align:center;">
      <button id="toggleAnimation">Pause</button>
    </div>

    <label>Color Presets</label>
    <div class="preset-container" id="colorPresetsStatic">
      <button class="preset-btn" data-start="#ff6f61" data-end="#330000">Fire</button>
      <button class="preset-btn" data-start="#6fffb0" data-end="#003311">Forest</button>
      <button class="preset-btn" data-start="#ffd166" data-end="#663300">Sunset</button>
      <button class="preset-btn" data-start="#c1e1ec" data-end="#0c2340">Ocean</button>
    </div>

    <label>Extra Features</label>
    <button id="toggleTrail">Enable Motion Trail</button>
    <button id="toggleWind">Enable Wind</button>

    <div id="stats">
      <div>FPS: <span id="fps">0</span></div>
      <div>Particles: <span id="currentParticles">0</span></div>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  let width, height;
  function resize() {
    width = window.innerWidth - 300;
    height = window.innerHeight;
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
    canvas.width = width * devicePixelRatio;
    canvas.height = height * devicePixelRatio;
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(devicePixelRatio, devicePixelRatio);
  }
  window.addEventListener('resize', resize);
  resize();

  // Color lerp unchanged
  function lerpColor(c0, c1, t) {
    const c0R = parseInt(c0.substring(1,3),16);
    const c0G = parseInt(c0.substring(3,5),16);
    const c0B = parseInt(c0.substring(5,7),16);
    const c1R = parseInt(c1.substring(1,3),16);
    const c1G = parseInt(c1.substring(3,5),16);
    const c1B = parseInt(c1.substring(5,7),16);
    const R = Math.round(c0R + (c1R - c0R) * t);
    const G = Math.round(c0G + (c1G - c0G) * t);
    const B = Math.round(c0B + (c1B - c0B) * t);
    return `rgb(${R},${G},${B})`;
  }

  // Shape draw helpers unchanged (circle, square, triangle, star)
  function drawCircle(ctx, x, y, r) {
    ctx.beginPath();
    ctx.arc(x, y, r, 0, 2 * Math.PI);
    ctx.fill();
  }
  function drawSquare(ctx, x, y, r) {
    ctx.beginPath();
    ctx.rect(x-r, y-r, r*2, r*2);
    ctx.fill();
  }
  function drawTriangle(ctx, x, y, r) {
    ctx.beginPath();
    ctx.moveTo(x, y - r);
    ctx.lineTo(x + r * Math.sin(Math.PI/3), y + r/2);
    ctx.lineTo(x - r * Math.sin(Math.PI/3), y + r/2);
    ctx.closePath();
    ctx.fill();
  }
  function drawStar(ctx, x, y, r) {
    ctx.beginPath();
    const spikes = 5;
    const outerRadius = r;
    const innerRadius = r/2.5;
    let rot = Math.PI / 2 * 3;
    let cx = x;
    let cy = y;
    let step = Math.PI / spikes;

    ctx.moveTo(cx, cy - outerRadius);
    for(let i=0;i<spikes;i++){
      let x1 = cx + Math.cos(rot) * outerRadius;
      let y1 = cy + Math.sin(rot) * outerRadius;
      ctx.lineTo(x1, y1);
      rot += step;

      let x2 = cx + Math.cos(rot) * innerRadius;
      let y2 = cy + Math.sin(rot) * innerRadius;
      ctx.lineTo(x2, y2);
      rot += step;
    }
    ctx.lineTo(cx, cy - outerRadius);
    ctx.closePath();
    ctx.fill();
  }

  // Particle class unchanged but reset uses proper width, height for looping
  class Particle {
    constructor(width, height, size, speed, gravity, colorStart, colorEnd, shape){
      this.width = width;
      this.height = height;
      this.sizeBase = size;
      this.speedBase = speed;
      this.gravity = gravity;
      this.colorStart = colorStart;
      this.colorEnd = colorEnd;
      this.shape = shape;

      this.reset();
    }
    reset(){
      this.x = Math.random() * this.width;
      this.y = Math.random() * this.height;
      this.size = this.sizeBase * (0.6 + Math.random()*0.8);
      this.speedX = (Math.random()*2-1) * this.speedBase;
      this.speedY = (Math.random()*2-1) * this.speedBase;
      this.gravityForce = this.gravity;
      this.life = 100 + Math.random()*100;
      this.age = 0;
      this.rotation = Math.random() * Math.PI*2;
      this.rotationSpeed = (Math.random()*2-1)*0.02;
    }
    update(windForce=0) {
      this.age++;
      this.speedY += this.gravityForce;
      this.speedX += windForce;
      this.x += this.speedX;
      this.y += this.speedY;
      this.rotation += this.rotationSpeed;

      if(this.x < -this.size) this.x = this.width + this.size;
      else if(this.x > this.width + this.size) this.x = -this.size;
      if(this.y < -this.size) this.y = this.height + this.size;
      else if(this.y > this.height + this.size) this.y = -this.size;

      if(this.age > this.life) this.reset();
    }
    draw(ctx){
      const t = this.age / this.life;
      ctx.fillStyle = lerpColor(this.colorStart, this.colorEnd, t);
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.rotation);
      switch(this.shape){
        case 'circle': drawCircle(ctx, 0, 0, this.size); break;
        case 'square': drawSquare(ctx, 0, 0, this.size); break;
        case 'triangle': drawTriangle(ctx, 0, 0, this.size); break;
        case 'star': drawStar(ctx, 0, 0, this.size); break;
        default: drawCircle(ctx, 0, 0, this.size);
      }
      ctx.restore();
    }
  }

  // Setup presetCategories minimally for functionality
  const presetCategories = {
    basic: [
      {label:"Basic Float", shape:"circle", speed:"2", size:"4", gravity:"0", colorStart:"#75c7ff", colorEnd:"#1a1a1a"},
      {label:"Soft Glow", shape:"star", speed:"1.5", size:"6", gravity:"0", colorStart:"#ff9eff", colorEnd:"#221144"}
    ],
    fireworks: [
      {label:"Red Burst", shape:"star", speed:"6", size:"5", gravity:"0.05", colorStart:"#ff6f61", colorEnd:"#330000"},
      {label:"Blue Spark", shape:"triangle", speed:"8", size:"3", gravity:"-0.02", colorStart:"#6fffb0", colorEnd:"#003311"}
    ],
    space: [
      {label:"Cosmic Drift", shape:"circle", speed:"2.5", size:"3", gravity:"0", colorStart:"#c1e1ec", colorEnd:"#0c2340"},
      {label:"Starfield", shape:"star", speed:"4", size:"2", gravity:"0", colorStart:"#ffffff", colorEnd:"#555555"}
    ],
    nature: [
      {label:"Forest Dust", shape:"square", speed:"1", size:"4", gravity:"0", colorStart:"#6fffb0", colorEnd:"#003311"},
      {label:"Sunset Glow", shape:"circle", speed:"3", size:"5", gravity:"0.01", colorStart:"#ffd166", colorEnd:"#663300"}
    ]
  };

  let particles = [];
  let particleCount = 300;
  let particleSpeed = 2;
  let particleSize = 4;
  let gravity = 0;
  let shape = 'circle';
  let colorStart = '#ff9eff';
  let colorEnd = '#221144';
  let fpsElem = document.getElementById('fps');
  let currentParticlesElem = document.getElementById('currentParticles');
  let isRunning = true;
  let trailEnabled = true; // enable trail for dreamy effect
  let windEnabled = true;  // slight wind for swirling
  let windForce = 0;

  const inputNum = document.getElementById('numParticles');
  const inputSpeed = document.getElementById('speed');
  const inputSize = document.getElementById('size');
  const inputGravity = document.getElementById('gravity');
  const inputShape = document.getElementById('shape');
  const inputColorStart = document.getElementById('colorStart');
  const inputColorEnd = document.getElementById('colorEnd');
  const btnToggle = document.getElementById('toggleAnimation');
  const btnTrail = document.getElementById('toggleTrail');
  const btnWind = document.getElementById('toggleWind');
  const presetButtonsStatic = document.querySelectorAll('#colorPresetsStatic .preset-btn');
  const presetCategorySelect = document.getElementById('presetCategory');
  const presetSelectionContainer = document.getElementById('presetSelection');

  inputColorStart.value = '#ff9eff';
  inputColorEnd.value = '#221144';

  function fillPresetSelection(category){
    presetSelectionContainer.innerHTML = '';
    const presets = presetCategories[category] || [];
    for(const preset of presets){
      const btn = document.createElement('button');
      btn.className = 'preset-btn';
      btn.textContent = preset.label;
      btn.title = `Shape: ${preset.shape}, Speed: ${preset.speed}, Size: ${preset.size}, Gravity: ${preset.gravity}`;
      btn.dataset.shape = preset.shape;
      btn.dataset.speed = preset.speed;
      btn.dataset.size = preset.size;
      btn.dataset.gravity = preset.gravity;
      btn.dataset.colorStart = preset.colorStart;
      btn.dataset.colorEnd = preset.colorEnd;
      btn.onclick = () => {
        shape = btn.dataset.shape;
        particleSpeed = parseFloat(btn.dataset.speed);
        particleSize = parseFloat(btn.dataset.size);
        gravity = parseFloat(btn.dataset.gravity);
        colorStart = btn.dataset.colorStart;
        colorEnd = btn.dataset.colorEnd;
        inputShape.value = shape;
        inputSpeed.value = particleSpeed;
        inputSize.value = particleSize;
        inputGravity.value = gravity;
        inputColorStart.value = colorStart;
        inputColorEnd.value = colorEnd;
        particles.forEach(p => {
          p.shape = shape;
          p.speedBase = particleSpeed;
          p.gravityForce = gravity;
          p.sizeBase = particleSize;
          p.colorStart = colorStart;
          p.colorEnd = colorEnd;
          p.speedX = (Math.random()*2-1)*particleSpeed;
          p.speedY = (Math.random()*2-1)*particleSpeed;
          p.size = particleSize*(0.6 + Math.random()*0.8);
        });
      };
      presetSelectionContainer.appendChild(btn);
    }
  }
  presetCategorySelect.onchange = () => {
    fillPresetSelection(presetCategorySelect.value);
  };
  fillPresetSelection(presetCategorySelect.value);

  function recreateParticles() {
    particles = [];
    for(let i=0;i<particleCount;i++){
      particles.push(new Particle(width, height, particleSize, particleSpeed, gravity, colorStart, colorEnd, shape));
    }
  }

  inputNum.oninput = () => {
    particleCount = Math.min(1000, Math.max(10, +inputNum.value));
    recreateParticles();
  }
  inputSpeed.oninput = () => {
    particleSpeed = +inputSpeed.value;
    particles.forEach(p=>{
      p.speedBase = particleSpeed;
      p.speedX = (Math.random()*2-1)*particleSpeed;
      p.speedY = (Math.random()*2-1)*particleSpeed;
    });
  }
  inputSize.oninput = () => {
    particleSize = +inputSize.value;
    particles.forEach(p=>{
      p.sizeBase = particleSize;
      p.size = particleSize * (0.6 + Math.random()*0.8);
    });
  }
  inputGravity.oninput = () => {
    gravity = +inputGravity.value;
    particles.forEach(p=>{
      p.gravityForce = gravity;
    });
  }
  inputShape.onchange = () => {
    shape = inputShape.value;
    particles.forEach(p=>p.shape = shape);
  }
  inputColorStart.oninput = () => {
    colorStart = inputColorStart.value;
    particles.forEach(p=>{
      p.colorStart = colorStart;
    });
  }
  inputColorEnd.oninput = () => {
    colorEnd = inputColorEnd.value;
    particles.forEach(p=>{
      p.colorEnd = colorEnd;
    });
  }
  btnToggle.onclick = () => {
    isRunning = !isRunning;
    btnToggle.textContent = isRunning ? "Pause" : "Play";
    if(isRunning) {
      lastFrameTime = performance.now();
      loop();
    }
  }
  btnTrail.onclick = () => {
    trailEnabled = !trailEnabled;
    btnTrail.textContent = trailEnabled ? "Disable Motion Trail" : "Enable Motion Trail";
  }
  btnWind.onclick = () => {
    windEnabled = !windEnabled;
    btnWind.textContent = windEnabled ? "Disable Wind" : "Enable Wind";
    windForce = 0;
  }
  presetButtonsStatic.forEach(btn => {
    btn.onclick = () => {
      colorStart = btn.getAttribute('data-start');
      colorEnd = btn.getAttribute('data-end');
      inputColorStart.value = colorStart;
      inputColorEnd.value = colorEnd;
      particles.forEach(p=>{
        p.colorStart = colorStart;
        p.colorEnd = colorEnd;
      });
    }
  });

  recreateParticles();

  let lastFrameTime = performance.now();
  let frames = 0;
  let fps = 0;
  let fpsUpdateInterval = 500;
  let lastFpsUpdate = performance.now();

  // Store original speed and count for drag temporary change
  let origSpeed = particleSpeed;
  let origCount = particleCount;
  let dragActive = false;

  canvas.addEventListener('mousedown', (e) => {
    dragActive = true;
    origSpeed = particleSpeed;
    origCount = particleCount;
  });

  canvas.addEventListener('mouseup', (e) => {
    if(dragActive){
      dragActive = false;
      // Restore inputs and parameters
      particleSpeed = origSpeed;
      particleCount = origCount;
      inputSpeed.value = origSpeed;
      inputNum.value = origCount;
      recreateParticles();
    }
  });

  canvas.addEventListener('mouseleave', (e) => {
    if(dragActive){
      dragActive = false;
      particleSpeed = origSpeed;
      particleCount = origCount;
      inputSpeed.value = origSpeed;
      inputNum.value = origCount;
      recreateParticles();
    }
  });

  canvas.addEventListener('mousemove', (e) => {
    if(!dragActive) return;
    let ratioX = e.offsetX / width;
    let ratioY = e.offsetY / height;

    let newSpeed = Math.min(10, Math.max(0, 10 * ratioX));
    let newCount = Math.round(10 + 990 * ratioY);

    if(Math.abs(newSpeed - particleSpeed) > 0.01 || newCount !== particleCount){
      particleSpeed = newSpeed;
      particleCount = newCount;
      inputSpeed.value = newSpeed.toFixed(2);
      inputNum.value = newCount;
      recreateParticles();
    }
  });

  function loop(t=performance.now()){
    if(!isRunning) return;
    requestAnimationFrame(loop);

    const dt = t - lastFrameTime;
    lastFrameTime = t;
    frames++;

    if(t - lastFpsUpdate > fpsUpdateInterval){
      fps = Math.round(frames * 1000 / (t - lastFpsUpdate));
      lastFpsUpdate = t;
      frames = 0;
      fpsElem.textContent = fps;
      currentParticlesElem.textContent = particles.length;
    }

    if(!trailEnabled){
      ctx.clearRect(0, 0, width, height);
    } else {
      ctx.fillStyle = 'rgba(34,17,68,0.12)';
      ctx.fillRect(0,0,width,height);
    }

    if(windEnabled){
      windForce = Math.sin(t/800)*0.03 + Math.cos(t/1200)*0.02;
    } else {
      windForce = 0;
    }

    for(let p of particles){
      p.update(windForce);
      p.draw(ctx);
    }
  }
  loop();
})();
</script>
</body>
</html> -->
