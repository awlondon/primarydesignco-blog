<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Anomaly Detection Engine (ADE) — Demo</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #0f1115;
      color: #e6e8eb;
      margin: 0;
      padding: 2rem;
    }
    .container { max-width: 860px; margin: 0 auto; }
    h1 { font-size: 2rem; margin-bottom: 0.5rem; }
    p { line-height: 1.6; color: #b7bcc5; }

    textarea {
      width: 100%;
      min-height: 180px;
      margin-top: 1.5rem;
      padding: 1rem;
      font-size: 1rem;
      background: #161a22;
      color: #e6e8eb;
      border: 1px solid #2a2f3a;
      border-radius: 8px;
      resize: vertical;
    }

    .controls {
      display: flex;
      gap: 1rem;
      align-items: end;
      flex-wrap: wrap;
      margin-top: 1rem;
    }

    select {
      margin-top: 0.25rem;
      padding: 0.4rem;
      background: #161a22;
      color: #e6e8eb;
      border: 1px solid #2a2f3a;
      border-radius: 6px;
    }

    button {
      margin-top: 1rem;
      padding: 0.7rem 1.2rem;
      font-size: 0.95rem;
      background: #2f6bff;
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }
    button:hover { background: #2456cc; }

    .output {
      margin-top: 2rem;
      padding: 1.5rem;
      background: #161a22;
      border: 1px solid #2a2f3a;
      border-radius: 8px;
    }
    .metric { margin-bottom: 1rem; }
    .label {
      font-size: 0.85rem;
      text-transform: uppercase;
      color: #8f96a3;
      letter-spacing: 0.05em;
    }
    .value { font-size: 1.1rem; margin-top: 0.25rem; }

    .note { margin-top: 2rem; font-size: 0.85rem; color: #8f96a3; }

    /* Claim emphasis */
    .claim {
      padding: 0.6rem 0.75rem;
      margin-bottom: 0.75rem;
      border-radius: 6px;
      line-height: 1.45;
    }
    .claim.common { opacity: 0.60; }
    .claim.recombination { opacity: 0.88; }
    .claim.anomalous {
      opacity: 1;
      border-left: 3px solid #4f7cff;
      background: rgba(79, 124, 255, 0.06);
    }
    .claim.canonical { opacity: 0.42; font-style: italic; }

    /* New: unanchored anomaly state */
    .claim.unanchored {
      opacity: 1;
      border-left: 3px solid #b08cff;
      background: rgba(176, 140, 255, 0.06);
    }

    /* New: low-coherence/noise */
    .claim.noise {
      opacity: 0.65;
      border-left: 3px solid #ff7a7a;
      background: rgba(255, 122, 122, 0.06);
    }

    .claim-meta {
      font-size: 0.8rem;
      color: #8f96a3;
      margin-top: 0.25rem;
    }

    .error {
      display: none;
      margin-top: 1rem;
      padding: 0.8rem 1rem;
      border-radius: 8px;
      background: rgba(255, 122, 122, 0.10);
      border: 1px solid rgba(255, 122, 122, 0.25);
      color: #ffd0d0;
      font-size: 0.95rem;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>Anomaly Detection Engine (ADE)</h1>
    <p>
      This demo evaluates <strong>predictability</strong>, not truth. It decomposes your input,
      positions each component against prior art, and estimates where—if anywhere—your thinking
      departs meaningfully from existing knowledge.
    </p>

    <div class="controls">
      <div>
        <label style="display:block; font-size:0.85rem; color:#8f96a3;">Domain lens</label>
        <select id="domain">
          <option value="general">General</option>
          <option value="philosophy">Philosophy / Theory</option>
          <option value="science">Science / Engineering</option>
          <option value="design">Design / Creative</option>
          <option value="political">Political / Social</option>
        </select>
      </div>

      <div>
        <label style="display:block; font-size:0.85rem; color:#8f96a3;">Mode</label>
        <select id="mode">
          <option value="strict">Strict (rarer anomaly)</option>
          <option value="exploratory">Exploratory (more sensitivity)</option>
        </select>
      </div>
    </div>

    <textarea id="input" placeholder="Type your hypothesis or idea..."></textarea>
    <button id="evaluateBtn" type="button">Evaluate</button>

    <div id="error" class="error"></div>

    <div id="output" class="output" style="display:none;">
      <div class="metric">
        <div class="label">Estimated anomaly score</div>
        <div class="value" id="score"></div>
      </div>

      <div class="metric">
        <div class="label">Anchoring and coherence</div>
        <div class="value" id="anchors"></div>
      </div>

      <div class="metric">
        <div class="label">Interpretation</div>
        <div class="value" id="interpretation"></div>
      </div>

      <div class="metric">
        <div class="label">Lineage signals</div>
        <div class="value" id="lineage"></div>
      </div>
    </div>

    <div class="note">
      This is a conceptual demonstration. No claims about correctness, usefulness, or truth are made.
      Scores reflect deviation under constraint, not merit.
    </div>
  </div>

<script>
(function () {
  const DOMAIN_THRESHOLDS = {
    general:    { anomalous: 78, recombination: 58, common: 38 },
    philosophy:{ anomalous: 74, recombination: 54, common: 36 },
    science:   { anomalous: 82, recombination: 62, common: 42 },
    design:    { anomalous: 75, recombination: 55, common: 35 },
    political: { anomalous: 85, recombination: 65, common: 45 }
  };

  // Domain anchoring lexicons (intentionally small + conservative)
  const DOMAIN_LEX = {
    general: [
      "model","system","economy","value","human","knowledge","idea","hypothesis","evidence","truth","bias"
    ],
    philosophy: [
      "epistem","ontology","norm","ethic","phenomen","meaning","reason","metaphys","validity","interpret"
    ],
    science: [
      "experiment","measure","method","hypothesis","data","variable","model","error","signal","causal","mechanism","falsif"
    ],
    design: [
      "prototype","iteration","constraint","affordance","interface","usability","aesthetic","workflow","artifact","practice"
    ],
    political: [
      "institution","legitim","govern","policy","power","public","democracy","equity","rights","collective","state"
    ]
  };

  const STOPWORDS = new Set([
    "the","a","an","and","or","but","if","then","than","that","this","those","these","to","of","in","on","for","with",
    "as","by","at","from","is","are","was","were","be","been","being","it","its","they","their","we","our","you","your",
    "not","rather","however","therefore","because","can","cannot","will","would","should","could","may","might"
  ]);

  function showError(msg) {
    const el = document.getElementById("error");
    el.textContent = msg;
    el.style.display = "block";
  }

  function clearError() {
    const el = document.getElementById("error");
    el.textContent = "";
    el.style.display = "none";
  }

  // Safari-safe sentence split
  function splitClaims(text) {
    return text
      .replace(/([.!?])/g, "$1|")
      .split("|")
      .map(s => s.trim())
      .filter(Boolean);
  }

  function tokenize(s) {
    return s
      .toLowerCase()
      .split(/[^a-z0-9]+/g)
      .filter(Boolean);
  }

  function computeCoherence(claimTokens) {
    // Heuristic: coherent text has (a) reasonable stopword share, (b) not extreme word-length, (c) not excessive rare-looking jargon chains.
    if (!claimTokens.length) return 0;

    const stopCount = claimTokens.filter(w => STOPWORDS.has(w)).length;
    const stopRatio = stopCount / claimTokens.length;

    const avgLen = claimTokens.reduce((s,w)=>s+w.length,0) / claimTokens.length;
    const longRatio = claimTokens.filter(w => w.length >= 12).length / claimTokens.length;

    // Score components (bounded)
    const stopScore = 1 - Math.min(Math.abs(stopRatio - 0.40) / 0.40, 1); // peak near 0.40
    const lenScore = 1 - Math.min(Math.abs(avgLen - 5.0) / 5.0, 1);      // peak near 5 chars
    const longPenalty = Math.min(longRatio / 0.45, 1);                   // too many long tokens => penalty

    const raw = 0.45 * stopScore + 0.45 * lenScore + 0.10 * (1 - longPenalty);
    return Math.round(Math.max(0, Math.min(raw, 1)) * 100);
  }

  function computeAnchoring(claimTokens, domain) {
    // Anchoring = domain lexicon hits + concrete referents (numbers/proper-ish) + explicit mechanisms/relations.
    if (!claimTokens.length) return 0;

    const lex = DOMAIN_LEX[domain] || DOMAIN_LEX.general;
    let lexHits = 0;

    for (const t of claimTokens) {
      for (const k of lex) {
        if (t.startsWith(k)) { lexHits += 1; break; }
      }
    }
    const lexScore = Math.min(lexHits / 6, 1); // 0..1

    const hasNumber = claimTokens.some(w => /\d/.test(w));
    const concreteScore = hasNumber ? 0.15 : 0;

    const relationScore =
      /because|therefore|implies|causes|leads|results|under|unless|rather|instead/i.test(claimTokens.join(" "))
        ? 0.20 : 0;

    const raw = 0.65 * lexScore + concreteScore + relationScore;
    return Math.round(Math.max(0, Math.min(raw, 1)) * 100);
  }

  function computeAnomaly(claim, claimTokens, mode) {
    // “Predictability” proxy: density + structure. This is not truth.
    const unique = new Set(claimTokens).size;

    const lengthScore = Math.min(claim.length / 220, 1);
    const densityScore = Math.min(unique / 26, 1);
    const structureScore = /because|therefore|if|but|however|rather than|implies|unless/i.test(claim) ? 0.15 : 0;
    const punctuationScore = /[:;()]/.test(claim) ? 0.08 : 0;

    let raw = 0.35 * lengthScore + 0.45 * densityScore + structureScore + punctuationScore;

    // Mode: strict reduces anomaly inflation; exploratory increases sensitivity.
    raw = mode === "exploratory" ? raw * 1.06 : raw * 0.98;

    let score = Math.round(Math.min(Math.max(raw, 0), 1) * 100);

    // Prevent punchy one-liners from becoming “anomalous”
    if (claim.length < 120) score = Math.min(score, 75);

    const uncertainty = Math.round(10 + (1 - Math.min(raw, 1)) * 15);
    return { score, uncertainty };
  }

  function classify(claim, domain, mode) {
    const tokens = tokenize(claim);
    const coherence = computeCoherence(tokens);
    const anchoring = computeAnchoring(tokens, domain);
    const { score, uncertainty } = computeAnomaly(claim, tokens, mode);
    const t = DOMAIN_THRESHOLDS[domain] || DOMAIN_THRESHOLDS.general;

    // Interpretation logic across axes:
    // - Low coherence => noise/low interpretability
    // - Low anchoring + moderate/high anomaly => unanchored anomaly (pre-paradigmatic)
    // - Otherwise use domain thresholds as before
    let category, cls, suggestion;

    if (coherence < 35) {
      category = "Low coherence / noise";
      cls = "noise";
      suggestion = "Clarify terms and causal structure. Reduce jargon density or define primitives.";
    } else if (anchoring < 28 && score >= t.common) {
      category = "Unanchored anomaly";
      cls = "unanchored";
      suggestion = "Add domain anchors: define terms, specify mechanism, and state what would falsify it.";
    } else if (score >= t.anomalous) {
      category = "Structural deviation";
      cls = "anomalous";
      suggestion = "Formalize the deviation: state mechanism + test or prediction.";
    } else if (score >= t.recombination) {
      category = "Recombination of known ideas";
      cls = "recombination";
      suggestion = "Identify the altered assumption and sharpen the constraint that makes it nontrivial.";
    } else if (score >= t.common) {
      category = "Common framing";
      cls = "common";
      suggestion = "Try changing scale (micro ↔ macro) or adding a constraint/counterfactual.";
    } else {
      category = "Highly canonical";
      cls = "canonical";
      suggestion = "Introduce a counterfactual or invert a core assumption.";
    }

    return {
      claim, score, uncertainty, anchoring, coherence,
      category, cls, suggestion
    };
  }

  function interpretOverall(analyses, domain) {
    const t = DOMAIN_THRESHOLDS[domain] || DOMAIN_THRESHOLDS.general;

    const avgAnom = Math.round(analyses.reduce((s,a)=>s+a.score,0) / analyses.length);
    const avgUnc  = Math.round(analyses.reduce((s,a)=>s+a.uncertainty,0) / analyses.length);
    const avgAnch = Math.round(analyses.reduce((s,a)=>s+a.anchoring,0) / analyses.length);
    const avgCoh  = Math.round(analyses.reduce((s,a)=>s+a.coherence,0) / analyses.length);

    // Overall interpretation should not call unanchored content “expected”.
    const anyNoise = analyses.some(a => a.category === "Low coherence / noise");
    const anyUnanchored = analyses.some(a => a.category === "Unanchored anomaly");
    const anyStructural = analyses.some(a => a.category === "Structural deviation");

    let text;
    if (anyNoise && avgCoh < 45) {
      text = "Overall input is weakly interpretable (low coherence). Clarify primitives and causal links before scoring meaningfully.";
    } else if (anyUnanchored && avgAnch < 35) {
      text = "Overall input contains novel but weakly anchored claims. Add definitions, mechanisms, and falsifiable hooks to make anomaly legible.";
    } else if (avgAnom >= t.anomalous || anyStructural) {
      text = "Overall input shows significant conceptual deviation (with at least one structurally atypical claim).";
    } else if (avgAnom >= t.recombination) {
      text = "Overall input shows non-trivial synthesis (recombination) with limited structural deviation.";
    } else if (avgAnom >= t.common) {
      text = "Overall input is competent but expected within this domain lens.";
    } else {
      text = "Overall input closely tracks canonical formulations within this domain lens.";
    }

    return { avgAnom, avgUnc, avgAnch, avgCoh, text };
  }

  function runADE() {
    clearError();

    const inputEl = document.getElementById("input");
    if (!inputEl) { showError("Internal error: input element not found."); return; }

    const text = (inputEl.value || "").trim();
    if (!text) return;

    const domainEl = document.getElementById("domain");
    const modeEl = document.getElementById("mode");
    const domain = domainEl ? domainEl.value : "general";
    const mode = modeEl ? modeEl.value : "strict";

    const claims = splitClaims(text);
    const analyses = claims.map(c => classify(c, domain, mode));
    if (!analyses.length) return;

    const overall = interpretOverall(analyses, domain);

    document.getElementById("score").innerText =
      `${overall.avgAnom} / 100 (±${overall.avgUnc})`;

    document.getElementById("anchors").innerText =
      `Anchoring: ${overall.avgAnch} / 100 · Coherence: ${overall.avgCoh} / 100`;

    document.getElementById("interpretation").innerText = overall.text;

    document.getElementById("lineage").innerHTML = analyses
      .map(a => `
        <div class="claim ${a.cls}">
          "${a.claim}"
          <div class="claim-meta">
            Anomaly: ${a.score} ± ${a.uncertainty} · Anchoring: ${a.anchoring} · Coherence: ${a.coherence}<br/>
            ${a.category}<br/>
            ↳ ${a.suggestion}
          </div>
        </div>
      `)
      .join("");

    document.getElementById("output").style.display = "block";
  }

  document.addEventListener("DOMContentLoaded", function () {
    const btn = document.getElementById("evaluateBtn");
    if (btn) btn.addEventListener("click", function () {
      try { runADE(); }
      catch (e) { showError("ADE runtime error: " + (e && e.message ? e.message : String(e))); }
    });
  });

  // Expose for debugging (optional)
  window.runADE = runADE;
})();
</script>
</body>
</html>
