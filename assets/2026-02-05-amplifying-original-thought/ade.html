<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Anomaly Detection Engine (ADE) — Demo</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #0f1115;
      color: #e6e8eb;
      margin: 0;
      padding: 2rem;
    }
    .container { max-width: 860px; margin: 0 auto; }
    h1 { font-size: 2rem; margin-bottom: 0.5rem; }
    p { line-height: 1.6; color: #b7bcc5; }

    textarea {
      width: 100%;
      min-height: 180px;
      margin-top: 1.5rem;
      padding: 1rem;
      font-size: 1rem;
      background: #161a22;
      color: #e6e8eb;
      border: 1px solid #2a2f3a;
      border-radius: 8px;
      resize: vertical;
    }

    .controls {
      display: flex;
      gap: 1rem;
      align-items: end;
      flex-wrap: wrap;
      margin-top: 1rem;
    }

    select {
      margin-top: 0.25rem;
      padding: 0.4rem;
      background: #161a22;
      color: #e6e8eb;
      border: 1px solid #2a2f3a;
      border-radius: 6px;
    }

    button {
      margin-top: 1rem;
      padding: 0.7rem 1.2rem;
      font-size: 0.95rem;
      background: #2f6bff;
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }
    button:hover { background: #2456cc; }

    .output {
      margin-top: 2rem;
      padding: 1.5rem;
      background: #161a22;
      border: 1px solid #2a2f3a;
      border-radius: 8px;
    }
    .metric { margin-bottom: 1rem; }
    .label {
      font-size: 0.85rem;
      text-transform: uppercase;
      color: #8f96a3;
      letter-spacing: 0.05em;
    }
    .value { font-size: 1.1rem; margin-top: 0.25rem; }
    .note { margin-top: 2rem; font-size: 0.85rem; color: #8f96a3; }

    /* Claim emphasis */
    .claim {
      padding: 0.6rem 0.75rem;
      margin-bottom: 0.75rem;
      border-radius: 6px;
      line-height: 1.45;
      border-left: 3px solid transparent;
    }
    .claim.common { opacity: 0.60; }
    .claim.recombination { opacity: 0.88; }
    .claim.anomalous {
      opacity: 1;
      border-left-color: #4f7cff;
      background: rgba(79, 124, 255, 0.06);
    }
    .claim.canonical { opacity: 0.42; font-style: italic; }

    /* New: unanchored anomaly state */
    .claim.unanchored {
      opacity: 1;
      border-left-color: #b08cff;
      background: rgba(176, 140, 255, 0.06);
    }

    /* New: low-coherence/noise */
    .claim.noise {
      opacity: 0.75;
      border-left-color: #ff7a7a;
      background: rgba(255, 122, 122, 0.06);
    }

    /* New: degenerate repetition / low-information */
    .claim.degenerate {
      opacity: 0.92;
      border-left-color: #ffd166;
      background: rgba(255, 209, 102, 0.07);
    }

    .claim-meta {
      font-size: 0.8rem;
      color: #8f96a3;
      margin-top: 0.25rem;
    }

    .error {
      display: none;
      margin-top: 1rem;
      padding: 0.8rem 1rem;
      border-radius: 8px;
      background: rgba(255, 122, 122, 0.10);
      border: 1px solid rgba(255, 122, 122, 0.25);
      color: #ffd0d0;
      font-size: 0.95rem;
    }

    .tiny {
      font-size: 0.78rem;
      color: #8f96a3;
      margin-top: 0.35rem;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>Anomaly Detection Engine (ADE)</h1>
    <p>
      This demo evaluates <strong>predictability</strong>, not truth. It decomposes your input,
      positions each component against prior art, and estimates where—if anywhere—your thinking
      departs meaningfully from existing knowledge.
    </p>

    <div class="controls">
      <div>
        <label style="display:block; font-size:0.85rem; color:#8f96a3;">Domain lens</label>
        <select id="domain">
          <option value="general">General</option>
          <option value="philosophy">Philosophy / Theory</option>
          <option value="science">Science / Engineering</option>
          <option value="design">Design / Creative</option>
          <option value="political">Political / Social</option>
        </select>
      </div>

      <div>
        <label style="display:block; font-size:0.85rem; color:#8f96a3;">Mode</label>
        <select id="mode">
          <option value="strict">Strict (rarer anomaly)</option>
          <option value="exploratory">Exploratory (more sensitivity)</option>
        </select>
        <div class="tiny">ADE build: v3 (anchoring + coherence + information)</div>
      </div>
    </div>

    <textarea id="input" placeholder="Type your hypothesis or idea..."></textarea>
    <button id="evaluateBtn" type="button">Evaluate</button>

    <div id="error" class="error"></div>

    <div id="output" class="output" style="display:none;">
      <div class="metric">
        <div class="label">Estimated anomaly score</div>
        <div class="value" id="score"></div>
      </div>

      <div class="metric">
        <div class="label">Anchoring, coherence, information</div>
        <div class="value" id="axes"></div>
      </div>

      <div class="metric">
        <div class="label">Interpretation</div>
        <div class="value" id="interpretation"></div>
      </div>

      <div class="metric">
        <div class="label">Lineage signals</div>
        <div class="value" id="lineage"></div>
      </div>
    </div>

    <div class="note">
      This is a conceptual demonstration. No claims about correctness, usefulness, or truth are made.
      Scores reflect deviation under constraint, not merit.
    </div>
  </div>

<script>
(function () {
  const DOMAIN_THRESHOLDS = {
    general:    { anomalous: 78, recombination: 58, common: 38 },
    philosophy:{ anomalous: 74, recombination: 54, common: 36 },
    science:   { anomalous: 82, recombination: 62, common: 42 },
    design:    { anomalous: 75, recombination: 55, common: 35 },
    political: { anomalous: 85, recombination: 65, common: 45 }
  };

  // Small, conservative lexicons
  const DOMAIN_LEX = {
    general: [
      "model","system","economy","value","human","knowledge","idea","hypothesis","evidence","truth","bias"
    ],
    philosophy: [
      "epistem","ontology","norm","ethic","phenomen","meaning","reason","metaphys","validity","interpret"
    ],
    science: [
      "experiment","measure","method","hypothesis","data","variable","model","error","signal","causal","mechanism","falsif"
    ],
    design: [
      "prototype","iteration","constraint","affordance","interface","usability","aesthetic","workflow","artifact","practice"
    ],
    political: [
      "institution","legitim","govern","policy","power","public","democracy","equity","rights","collective","state"
    ]
  };

  const STOPWORDS = new Set([
    "the","a","an","and","or","but","if","then","than","that","this","those","these","to","of","in","on","for","with",
    "as","by","at","from","is","are","was","were","be","been","being","it","its","they","their","we","our","you","your",
    "not","rather","however","therefore","because","can","cannot","will","would","should","could","may","might","please"
  ]);

  function showError(msg) {
    const el = document.getElementById("error");
    el.textContent = msg;
    el.style.display = "block";
  }
  function clearError() {
    const el = document.getElementById("error");
    el.textContent = "";
    el.style.display = "none";
  }

  function splitClaims(text) {
    return text
      .replace(/([.!?])/g, "$1|")
      .split("|")
      .map(s => s.trim())
      .filter(Boolean);
  }

  function tokenize(s) {
    return s.toLowerCase().split(/[^a-z0-9]+/g).filter(Boolean);
  }

  function computeCoherence(tokens) {
    if (!tokens.length) return 0;

    const stopCount = tokens.filter(w => STOPWORDS.has(w)).length;
    const stopRatio = stopCount / tokens.length;

    const avgLen = tokens.reduce((s,w)=>s+w.length,0) / tokens.length;
    const longRatio = tokens.filter(w => w.length >= 12).length / tokens.length;

    const stopScore = 1 - Math.min(Math.abs(stopRatio - 0.40) / 0.40, 1);
    const lenScore  = 1 - Math.min(Math.abs(avgLen - 5.0) / 5.0, 1);
    const longPenalty = Math.min(longRatio / 0.45, 1);

    const raw = 0.45 * stopScore + 0.45 * lenScore + 0.10 * (1 - longPenalty);
    return Math.round(Math.max(0, Math.min(raw, 1)) * 100);
  }

  function computeAnchoring(tokens, domain, rawText) {
    if (!tokens.length) return 0;

    const lex = DOMAIN_LEX[domain] || DOMAIN_LEX.general;
    let lexHits = 0;
    for (const t of tokens) {
      for (const k of lex) {
        if (t.startsWith(k)) { lexHits += 1; break; }
      }
    }
    const lexScore = Math.min(lexHits / 6, 1);

    const hasNumber = tokens.some(w => /\d/.test(w));
    const concreteScore = hasNumber ? 0.15 : 0;

    const relationScore =
      /because|therefore|implies|causes|leads|results|under|unless|rather|instead/i.test(rawText)
        ? 0.20 : 0;

    const raw = 0.65 * lexScore + concreteScore + relationScore;
    return Math.round(Math.max(0, Math.min(raw, 1)) * 100);
  }

  // NEW: Information / anti-repetition
  function computeInformation(tokens) {
    if (!tokens.length) return 0;

    // Unique ratio (variety)
    const unique = new Set(tokens);
    const uniqueRatio = unique.size / tokens.length; // 0..1

    // Dominance (single token repeats too much)
    const freq = new Map();
    for (const t of tokens) freq.set(t, (freq.get(t) || 0) + 1);
    const topCount = Math.max(...freq.values());
    const dominance = topCount / tokens.length; // 0..1

    // Bigram repetition ratio (phrase looping)
    let bigrams = 0, repeatedBigrams = 0;
    const seen = new Map();
    for (let i = 0; i < tokens.length - 1; i++) {
      const bg = tokens[i] + " " + tokens[i+1];
      bigrams++;
      seen.set(bg, (seen.get(bg) || 0) + 1);
    }
    for (const c of seen.values()) if (c > 1) repeatedBigrams += c;
    const bigramRepeatRatio = bigrams ? (repeatedBigrams / bigrams) : 0; // 0..1

    // Novelty slope: how quickly new tokens stop appearing
    // Count unique growth across 10 segments; flat growth => repetition.
    const segments = 10;
    const segSize = Math.max(1, Math.floor(tokens.length / segments));
    let u = new Set();
    let growth = [];
    for (let s = 0; s < segments; s++) {
      const start = s * segSize;
      const end = (s === segments - 1) ? tokens.length : Math.min(tokens.length, (s+1) * segSize);
      for (let i = start; i < end; i++) u.add(tokens[i]);
      growth.push(u.size);
    }
    // Normalize slope: last growth minus early growth
    const slope = (growth[growth.length - 1] - growth[Math.min(2, growth.length - 1)]) / Math.max(1, tokens.length);
    // slope near 0 => stagnation

    // Combine into information score (higher = more informational)
    // Penalize dominance & repeated bigrams; reward unique ratio and slope.
    const variety = Math.min(uniqueRatio / 0.45, 1);         // ~0.45+ is “good variety”
    const slopeScore = Math.min(slope / 0.03, 1);            // small but meaningful slopes
    const dominancePenalty = Math.min(dominance / 0.45, 1);  // >0.45 top token is a problem
    const bigramPenalty = Math.min(bigramRepeatRatio / 0.60, 1);

    const raw = (0.50 * variety + 0.20 * slopeScore + 0.30 * (1 - dominancePenalty)) * (1 - 0.35 * bigramPenalty);
    return Math.round(Math.max(0, Math.min(raw, 1)) * 100);
  }

  function computeAnomaly(rawText, tokens, mode) {
    const unique = new Set(tokens).size;

    const lengthScore = Math.min(rawText.length / 220, 1);
    const densityScore = Math.min(unique / 26, 1);
    const structureScore = /because|therefore|if|but|however|rather than|implies|unless/i.test(rawText) ? 0.15 : 0;
    const punctuationScore = /[:;()]/.test(rawText) ? 0.08 : 0;

    let raw = 0.35 * lengthScore + 0.45 * densityScore + structureScore + punctuationScore;
    raw = mode === "exploratory" ? raw * 1.06 : raw * 0.98;

    let score = Math.round(Math.min(Math.max(raw, 0), 1) * 100);
    if (rawText.length < 120) score = Math.min(score, 75);

    const uncertainty = Math.round(10 + (1 - Math.min(raw, 1)) * 15);
    return { score, uncertainty };
  }

  function classify(claim, domain, mode) {
    const tokens = tokenize(claim);

    const coherence = computeCoherence(tokens);
    const anchoring = computeAnchoring(tokens, domain, claim);
    const information = computeInformation(tokens);
    const { score, uncertainty } = computeAnomaly(claim, tokens, mode);
    const t = DOMAIN_THRESHOLDS[domain] || DOMAIN_THRESHOLDS.general;

    let category, cls, suggestion;

    // New priority: degenerate repetition should be caught before "unanchored anomaly"
    const degenerate = (information < 25) || (tokens.length > 40 && information < 35);

    if (coherence < 35) {
      category = "Low coherence / noise";
      cls = "noise";
      suggestion = "Clarify terms and causal structure. Reduce jargon density or define primitives.";
    } else if (degenerate) {
      category = "Degenerate repetition / low-information";
      cls = "degenerate";
      suggestion = "Reduce repetition and add new informational content (definitions, mechanism, constraints).";
    } else if (anchoring < 28 && score >= t.common) {
      category = "Unanchored anomaly";
      cls = "unanchored";
      suggestion = "Add domain anchors: define terms, specify mechanism, and state what would falsify it.";
    } else if (score >= t.anomalous) {
      category = "Structural deviation";
      cls = "anomalous";
      suggestion = "Formalize the deviation: state mechanism + test or prediction.";
    } else if (score >= t.recombination) {
      category = "Recombination of known ideas";
      cls = "recombination";
      suggestion = "Identify the altered assumption and sharpen the constraint that makes it nontrivial.";
    } else if (score >= t.common) {
      category = "Common framing";
      cls = "common";
      suggestion = "Try changing scale (micro ↔ macro) or adding a constraint/counterfactual.";
    } else {
      category = "Highly canonical";
      cls = "canonical";
      suggestion = "Introduce a counterfactual or invert a core assumption.";
    }

    return { claim, score, uncertainty, anchoring, coherence, information, category, cls, suggestion };
  }

  function interpretOverall(analyses, domain) {
    const t = DOMAIN_THRESHOLDS[domain] || DOMAIN_THRESHOLDS.general;

    const avgAnom = Math.round(analyses.reduce((s,a)=>s+a.score,0) / analyses.length);
    const avgUnc  = Math.round(analyses.reduce((s,a)=>s+a.uncertainty,0) / analyses.length);
    const avgAnch = Math.round(analyses.reduce((s,a)=>s+a.anchoring,0) / analyses.length);
    const avgCoh  = Math.round(analyses.reduce((s,a)=>s+a.coherence,0) / analyses.length);
    const avgInfo = Math.round(analyses.reduce((s,a)=>s+a.information,0) / analyses.length);

    const anyNoise = analyses.some(a => a.category === "Low coherence / noise");
    const anyDeg   = analyses.some(a => a.category === "Degenerate repetition / low-information");
    const anyUnanchored = analyses.some(a => a.category === "Unanchored anomaly");
    const anyStructural = analyses.some(a => a.category === "Structural deviation");

    let text;
    if (anyNoise && avgCoh < 45) {
      text = "Overall input is weakly interpretable (low coherence). Clarify primitives and causal links before scoring meaningfully.";
    } else if (anyDeg || avgInfo < 30) {
      text = "Overall input is low-information (high redundancy). Reduce repetition and add definitions, mechanisms, and constraints.";
    } else if (anyUnanchored && avgAnch < 35) {
      text = "Overall input contains novel but weakly anchored claims. Add definitions, mechanisms, and falsifiable hooks to make anomaly legible.";
    } else if (avgAnom >= t.anomalous || anyStructural) {
      text = "Overall input shows significant conceptual deviation (with at least one structurally atypical claim).";
    } else if (avgAnom >= t.recombination) {
      text = "Overall input shows non-trivial synthesis (recombination) with limited structural deviation.";
    } else if (avgAnom >= t.common) {
      text = "Overall input is competent but expected within this domain lens.";
    } else {
      text = "Overall input closely tracks canonical formulations within this domain lens.";
    }

    return { avgAnom, avgUnc, avgAnch, avgCoh, avgInfo, text };
  }

  function runADE() {
    clearError();

    const inputEl = document.getElementById("input");
    const text = (inputEl && inputEl.value ? inputEl.value : "").trim();
    if (!text) return;

    const domainEl = document.getElementById("domain");
    const modeEl = document.getElementById("mode");
    const domain = domainEl ? domainEl.value : "general";
    const mode = modeEl ? modeEl.value : "strict";

    const claims = splitClaims(text);
    const analyses = claims.map(c => classify(c, domain, mode));
    if (!analyses.length) return;

    const overall = interpretOverall(analyses, domain);

    document.getElementById("score").innerText =
      `${overall.avgAnom} / 100 (±${overall.avgUnc})`;

    document.getElementById("axes").innerText =
      `Anchoring: ${overall.avgAnch} / 100 · Coherence: ${overall.avgCoh} / 100 · Information: ${overall.avgInfo} / 100`;

    document.getElementById("interpretation").innerText = overall.text;

    document.getElementById("lineage").innerHTML = analyses.map(a => `
      <div class="claim ${a.cls}">
        "${a.claim}"
        <div class="claim-meta">
          Anomaly: ${a.score} ± ${a.uncertainty} · Anchoring: ${a.anchoring} · Coherence: ${a.coherence} · Information: ${a.information}<br/>
          ${a.category}<br/>
          ↳ ${a.suggestion}
        </div>
      </div>
    `).join("");

    document.getElementById("output").style.display = "block";
  }

  document.addEventListener("DOMContentLoaded", function () {
    const btn = document.getElementById("evaluateBtn");
    if (!btn) { showError("Internal error: Evaluate button not found."); return; }
    btn.addEventListener("click", function () {
      try { runADE(); }
      catch (e) { showError("ADE runtime error: " + (e && e.message ? e.message : String(e))); }
    });
  });

  // Expose for debugging
  window.runADE = runADE;
})();
</script>
</body>
</html>
