<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8" /> <meta name="viewport" content="width=device-width, initial-scale=1" /> <title>Animated Pixel Cityscape Enhanced</title> <style> :root { --bg-color: #050510; --ui-color: #05d9e8; } body, html { margin: 0; padding: 0; width: 100%; height: 100%; background-color: var(--bg-color); overflow: hidden; display: flex; justify-content: center; align-items: center; user-select: none; font-family: 'Courier New', Courier, monospace; } #cityCanvas { width: 100vw; height: 100vh; object-fit: fill; /* Stretches exactly to the bounds, internal resolution handles the ratio */ image-rendering: -moz-crisp-edges; image-rendering: -webkit-optimize-contrast; image-rendering: crisp-edges; image-rendering: pixelated; background: transparent; will-change: transform; } /* Retro CRT Overlays */ .scanlines { position: absolute; inset: 0; pointer-events: none; z-index: 10; background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.2) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03)); background-size: 100% 4px, 6px 100%; } .vignette { position: absolute; inset: 0; pointer-events: none; z-index: 11; box-shadow: 0 0 200px rgba(0,0,0,0.85) inset; } /* Cyberpunk UI */ #ui { position: absolute; bottom: 25px; right: 25px; color: var(--ui-color); font-size: 14px; pointer-events: none; text-shadow: 0 0 8px rgba(5, 217, 232, 0.6); letter-spacing: 0.1em; z-index: 20; display: flex; align-items: center; } .cursor { display: inline-block; width: 8px; height: 14px; background-color: var(--ui-color); margin-left: 4px; animation: blink 1s step-end infinite; box-shadow: 0 0 8px rgba(5, 217, 232, 0.6); } @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } } </style> </head> <body> <canvas id="cityCanvas"></canvas> <div class="scanlines"></div> <div class="vignette"></div> <div id="ui"> <span class="text">SYSTEM.ONLINE // SECTOR 4</span> <span class="cursor"></span> </div> <script> (()=> { const canvas = document.getElementById('cityCanvas'); const ctx = canvas.getContext('2d', { alpha: false }); // Optimize by disabling alpha on base let W, H; const TARGET_HEIGHT = 250; // Fixed internal pixel height // --- Colors & Config --- const SKY_TOP = '#09091f'; const SKY_MID = '#3a1570'; const SKY_BOT = '#a33294'; const SUN_COLOR = '#FF3A94'; const PALETTES = { far: { base: ['#1F0B3A', '#26164A', '#1C0A39'], windows: ['#632b9a', '#591f8d', '#984fe6'], prob: 0.15, speed: 0.05 }, mid: { base: ['#3D1A66', '#3A1B5E', '#481F71'], windows: ['#FF3A94', '#D92578', '#9B1D54'], prob: 0.25, speed: 0.15 }, fore: { base: ['#121029', '#1C1653', '#0B0B17'], windows: ['#0DDEE8', '#F3D81C', '#0B8E9E', '#FF3A94'], prob: 0.40, speed: 0.40 } }; // Arrays to hold entities let stars = [], shootingStars = [], flyingCars = []; let layerFar = [], layerMid = [], layerFore = []; // --- Entities --- class Star { constructor() { this.x = Math.random() * W; this.y = Math.random() * (H * 0.7); this.size = (Math.random() < 0.93 ? 1 : 2); this.blinkSpeed = 0.005 + Math.random() * 0.03; this.phase = Math.random() * Math.PI * 2; } draw(t) { const blink = 0.3 + 0.7 * Math.abs(Math.sin(t * this.blinkSpeed + this.phase)); ctx.globalAlpha = blink; ctx.fillStyle = '#FFFFFF'; ctx.fillRect(this.x | 0, this.y | 0, this.size, this.size); } } class ShootingStar { constructor() { this.reset(); } reset() { this.x = W + Math.random() * (W * 2); // Spread them out this.y = Math.random() * (H * 0.4); this.length = 15 + Math.random() * 25; this.speed = 6 + Math.random() * 5; this.active = false; this.timer = Math.random() * 400 + 100; this.opacity = 0; } update() { if (!this.active) { if (--this.timer <= 0) { this.active = true; this.opacity = 1; } return; } this.x -= this.speed; this.y += this.speed * 0.25; this.opacity -= 0.015; if (this.x < -this.length || this.opacity <= 0) this.reset(); } draw() { if (!this.active) return; ctx.fillStyle = '#FFFFFF'; for(let i = 0; i < this.length; i += 2) { ctx.globalAlpha = Math.max(0, this.opacity * (1 - i / this.length)); ctx.fillRect((this.x + i) | 0, (this.y - i * 0.25) | 0, 2, 1); } } } class Building { constructor(x, layerType) { this.x = x; this.layer = layerType; this.config = PALETTES[layerType]; this.generate(); } generate() { let [minH, maxH, minW, maxW] = [0,0,0,0]; if (this.layer === 'far') [minH, maxH, minW, maxW] = [60, 140, 20, 50]; else if (this.layer === 'mid') [minH, maxH, minW, maxW] = [40, 180, 30, 75]; else [minH, maxH, minW, maxW] = [20, 210, 45, 120]; this.w = Math.floor(Math.random()*(maxW - minW) + minW); this.h = Math.floor(Math.random()*(maxH - minH) + minH); this.y = H - this.h; this.color = this.config.base[(Math.random() * this.config.base.length) | 0]; // Cache the gradient to avoid creating it every frame this.grad = ctx.createLinearGradient(0, this.y, 0, H); this.grad.addColorStop(0, this.color); this.grad.addColorStop(1, '#020205'); this.hasAntenna = Math.random() > 0.6; this.antennaHeight = Math.floor(Math.random()*20 + 5); this.hasBlinker = this.hasAntenna && (Math.random() > 0.4); this.blinkPhase = Math.random() * 2000; this.windows = []; const winWidth = this.layer === 'far' ? 1 : 2; const winHeight = this.layer === 'far' ? 2 : 3; const spacingX = winWidth + (this.layer === 'far' ? 2 : 3); const spacingY = winHeight + (this.layer === 'far' ? 3 : 4); for (let wy = 5; wy < this.h - 10; wy += spacingY) { // Group windows to look more like office blocks if (Math.random() > 0.85) continue; for (let wx = 4; wx < this.w - 4; wx += spacingX) { if (Math.random() < this.config.prob) { this.windows.push({ x: wx, y: wy, w: winWidth, h: winHeight, color: this.config.windows[(Math.random() * this.config.windows.length) | 0], flickerPhase: Math.random() * 100 }); } } } } update(buildingsArray) { this.x -= this.config.speed; if (this.x + this.w < 0) { // Move to the back of the line let rightmostX = 0; for (const b of buildingsArray) { if (b.x + b.w > rightmostX) rightmostX = b.x + b.w; } this.x = rightmostX; this.generate(); // Regenerate appearance } } draw(time) { const px = this.x | 0; // Draw Base ctx.globalAlpha = 1.0; ctx.fillStyle = this.grad; ctx.fillRect(px, this.y, this.w, this.h); // Draw Antenna if (this.hasAntenna) { const ax = px + (this.w/2) | 0; ctx.fillStyle = '#110522'; ctx.fillRect(ax, this.y - this.antennaHeight, 1, this.antennaHeight); if (this.hasBlinker) { const blinkTime = (time + this.blinkPhase) % 2000; if (blinkTime < 800) { ctx.globalAlpha = 0.4 + 0.6 * Math.sin(blinkTime / 250 * Math.PI); ctx.fillStyle = '#FF0000'; ctx.fillRect(ax - 1, this.y - this.antennaHeight - 1, 3, 2); } } } // Draw Windows (Optimized rendering with globalAlpha instead of string parsing) for (const win of this.windows) { if (Math.random() > 0.99) continue; // Micro-stutter for realism ctx.globalAlpha = 0.4 + 0.6 * Math.sin((time * 0.002) + win.flickerPhase); ctx.fillStyle = win.color; ctx.fillRect(px + win.x, this.y + win.y, win.w, win.h); } } } class FlyingCar { constructor() { this.reset(); this.x = Math.random() * W; } reset() { this.direction = Math.random() > 0.5 ? 1 : -1; this.speed = 1.5 + Math.random() * 3; if (this.direction === 1) { this.x = W + Math.random() * 300; } else { this.x = -50 - Math.random() * 300; this.speed *= -0.8; } this.baseY = Math.random() * (H - 80) + 20; this.color = Math.random() > 0.5 ? '#0DDCEF' : '#FF3A94'; this.trailColor = this.color === '#0DDCEF' ? '#FFFFFF' : '#FFB6C1'; this.size = 3 + Math.random() * 3; this.phase = Math.random() * Math.PI * 2; } update(time) { this.x -= this.speed; // Add subtle hover motion this.y = this.baseY + Math.sin(time * 0.002 + this.phase) * 3; if (this.direction === 1 && this.x < -50) this.reset(); else if (this.direction === -1 && this.x > W + 50) this.reset(); } draw(time) { const px = this.x | 0; const py = this.y | 0; const blink = 0.5 + 0.5 * Math.sin(time * 0.01 + this.phase); // Trail ctx.globalAlpha = blink * 0.8; ctx.fillStyle = this.trailColor; ctx.fillRect(px + (this.direction === 1 ? this.size : -4), py + 1, 4, 1); // Body ctx.globalAlpha = 1.0; ctx.fillStyle = this.color; ctx.fillRect(px, py, this.size | 0, 2); // Core highlight ctx.globalAlpha = blink; ctx.fillStyle = '#FFFFFF'; ctx.fillRect(px + 1, py, this.size - 2, 1); } } // --- Core System --- function populateLayer(layerArr, type) { let currentX = 0; // Generate enough to fill screen + buffer for wrapping while(currentX < W + 300) { const b = new Building(currentX, type); layerArr.push(b); currentX += b.w; } } function init() { // Dynamic pixel resolution calculation to prevent stretching const ratio = window.innerWidth / window.innerHeight; canvas.height = TARGET_HEIGHT; canvas.width = Math.floor(TARGET_HEIGHT * ratio); W = canvas.width; H = canvas.height; // Reset arrays on resize stars = Array.from({length: Math.floor(W * 0.2)}, () => new Star()); shootingStars = [new ShootingStar(), new ShootingStar(), new ShootingStar()]; flyingCars = Array.from({length: 8}, () => new FlyingCar()); layerFar = []; layerMid = []; layerFore = []; populateLayer(layerFar, 'far'); populateLayer(layerMid, 'mid'); populateLayer(layerFore, 'fore'); } function drawSkyAndSun(time) { ctx.globalAlpha = 1.0; // Dynamic Sky Gradient const gradient = ctx.createLinearGradient(0, 0, 0, H); gradient.addColorStop(0, SKY_TOP); let offset = 0.45 + 0.05 * Math.sin(time * 0.0002); gradient.addColorStop(offset, SKY_MID); gradient.addColorStop(1, SKY_BOT); ctx.fillStyle = gradient; ctx.fillRect(0, 0, W, H); // Draw Stars behind the sun for(let star of stars) star.draw(time); for(let ss of shootingStars) { ss.update(); ss.draw(); } // Synthwave Sun const sunX = (W * 0.65) | 0; const sunY = (H * 0.6) | 0; const baseRadius = H * 0.25; ctx.save(); // Sun Bloom ctx.shadowBlur = 30; ctx.shadowColor = SUN_COLOR; ctx.beginPath(); ctx.fillStyle = SUN_COLOR; ctx.arc(sunX, sunY, baseRadius, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0; // Apply retro cutouts using destination-out to clear lines ctx.globalCompositeOperation = 'destination-out'; const stripes = 12; for (let i = 0; i < stripes; i++) { // Lines get thicker towards the bottom const lineY = sunY - baseRadius + (2 * baseRadius / stripes) * i; const lineHeight = 1 + Math.pow(i, 1.2) * 0.25; const lineAlpha = 0.6 + 0.2 * Math.sin(time * 0.001 - i); ctx.globalAlpha = Math.min(1, lineAlpha); ctx.fillRect(sunX - baseRadius - 10, lineY + (baseRadius*0.2), baseRadius * 2 + 20, lineHeight); } ctx.restore(); } function animate(time=0) { drawSkyAndSun(time); ctx.globalAlpha = 1.0; // Reset alpha for standard drawing // Draw Layers with depth sorting for flying cars for(let b of layerFar) { b.update(layerFar); b.draw(time); } for(let i=0; i<3; i++) { flyingCars[i].update(time); flyingCars[i].draw(time); } for(let b of layerMid) { b.update(layerMid); b.draw(time); } for(let i=3; i<flyingCars.length; i++) { flyingCars[i].update(time); flyingCars[i].draw(time); } for(let b of layerFore) { b.update(layerFore); b.draw(time); } requestAnimationFrame(animate); } // Initialize and start window.addEventListener('resize', init); init(); requestAnimationFrame(animate); })(); </script> </body> </html>
