<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Cyberpunk City</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #050510;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(0, 255, 255, 0.5);
            font-family: 'Courier New', Courier, monospace;
            font-size: 12px;
            pointer-events: none;
            text-shadow: 0 0 5px cyan;
        }
    </style>
</head>
<body>
    <div id="ui">SYSTEM: ONLINE // PARALLAX: ACTIVE // RENDER: 2D</div>
    <canvas id="city"></canvas>

<script>
/**
 * CYBERPUNK CITY GENERATOR
 * Features: Parallax scrolling, procedural buildings, rain, neon glow, flying traffic.
 */

// Wrap in IIFE to prevent global scope pollution and variable collisions
(function() {
    const canvas = document.getElementById('city');
    const ctx = canvas.getContext('2d', { alpha: false });

    let w, h;
    let frame = 0;
    let animationId; // Store animation frame ID

    // Configuration
    const CONFIG = {
        colors: {
            skyTop: '#000000',
            skyBottom: '#180c2e',
            sun: ['#ff0055', '#ffcc00'],
            layer1: '#0a0a12', // Back
            layer2: '#121225', // Mid
            layer3: '#1a1a35', // Front
            windows: ['#00ffff', '#ff00ff', '#ffff00', '#ffffff'],
            neon: ['#ff0055', '#00ffff', '#ae00ff']
        },
        speed: 0.5, // Global scroll speed modifier
        rainIntensity: 100
    };

    // Utils
    const random = (min, max) => Math.random() * (max - min) + min;
    const randomInt = (min, max) => Math.floor(random(min, max));
    const randomChoice = (arr) => arr[Math.floor(Math.random() * arr.length)];

    class Starfield {
        constructor(count) {
            this.stars = [];
            this.count = count;
            this.init();
        }

        init() {
            this.stars = [];
            for (let i = 0; i < this.count; i++) {
                this.stars.push({
                    x: Math.random() * w,
                    y: Math.random() * h * 0.6, // Only in top 60%
                    size: Math.random() * 1.5,
                    blinkSpeed: Math.random() * 0.05
                });
            }
        }

        draw(t) {
            ctx.fillStyle = '#ffffff';
            this.stars.forEach(s => {
                const opacity = 0.3 + Math.abs(Math.sin(t * s.blinkSpeed)) * 0.7;
                ctx.globalAlpha = opacity;
                ctx.fillRect(s.x, s.y, s.size, s.size);
            });
            ctx.globalAlpha = 1.0;
        }
    }

    class Background {
        constructor() {
            this.sunY = 0;
        }
        
        draw() {
            // Sky Gradient
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, CONFIG.colors.skyTop);
            grad.addColorStop(1, CONFIG.colors.skyBottom);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);

            // Retro Sun
            const sunSize = Math.min(w, h) * 0.25;
            const sunX = w / 2;
            const sunY = h * 0.6;
            
            const sunGrad = ctx.createLinearGradient(sunX, sunY - sunSize, sunX, sunY + sunSize);
            sunGrad.addColorStop(0, CONFIG.colors.sun[1]);
            sunGrad.addColorStop(1, CONFIG.colors.sun[0]);

            ctx.save();
            ctx.shadowBlur = 50;
            ctx.shadowColor = CONFIG.colors.sun[0];
            ctx.fillStyle = sunGrad;
            ctx.beginPath();
            ctx.arc(sunX, sunY, sunSize, 0, Math.PI * 2);
            ctx.fill();

            // Sun lines (blind effect)
            ctx.fillStyle = CONFIG.colors.skyBottom;
            for(let i = 0; i < 10; i++) {
                const barH = i * 4 + 2;
                const barY = sunY + (i * 15);
                if (barY < sunY + sunSize) {
                    ctx.fillRect(sunX - sunSize, barY, sunSize * 2, barH);
                }
            }
            ctx.restore();
        }
    }

    class Building {
        constructor(x, layerWidth, color, isFrontLayer) {
            this.w = random(30, 80) * (isFrontLayer ? 1.5 : 1);
            this.h = random(h * 0.1, h * 0.5) * (isFrontLayer ? 1.2 : 0.8);
            this.x = x;
            this.y = h; 
            this.color = color;
            this.isFrontLayer = isFrontLayer;
            this.windows = [];
            this.neonSigns = [];
            this.hasAntenna = Math.random() > 0.7;
            
            this.generateDetails();
        }

        generateDetails() {
            // Generate Windows
            if (this.isFrontLayer || Math.random() > 0.5) {
                const cols = Math.floor(this.w / 10);
                const rows = Math.floor(this.h / 15);
                // Grid logic
                for (let r = 0; r < rows; r++) {
                    if (Math.random() > 0.6) continue; // Skip some rows
                    for (let c = 0; c < cols; c++) {
                        if (Math.random() > 0.3) {
                            this.windows.push({
                                x: c * 10 + 2,
                                y: r * 15 + 5,
                                w: 6,
                                h: 10,
                                color: randomChoice(CONFIG.colors.windows),
                                flicker: Math.random() > 0.95 // 5% chance to flicker
                            });
                        }
                    }
                }
            }

            // Generate Neon Signs (Front layer only)
            if (this.isFrontLayer && Math.random() > 0.6) {
                this.neonSigns.push({
                    x: random(5, this.w - 25),
                    y: random(20, this.h - 50),
                    w: 20,
                    h: random(20, 60),
                    color: randomChoice(CONFIG.colors.neon),
                    type: randomInt(0, 2) // 0 = vertical text, 1 = box
                });
            }
        }

        draw(ctx, scrollX) {
            const drawX = this.x - scrollX;
            
            // Base building
            ctx.fillStyle = this.color;
            ctx.fillRect(drawX, h - this.h, this.w, this.h);

            // Antenna
            if (this.hasAntenna) {
                ctx.beginPath();
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.moveTo(drawX + this.w/2, h - this.h);
                ctx.lineTo(drawX + this.w/2, h - this.h - 20);
                ctx.stroke();
                // Blinking light on top
                if (Math.floor(frame / 30) % 2 === 0) {
                    ctx.fillStyle = 'red';
                    ctx.fillRect(drawX + this.w/2 - 1, h - this.h - 22, 3, 3);
                }
            }

            // Details only if visible
            if (drawX > -this.w && drawX < w) {
                // Windows
                this.windows.forEach(win => {
                    const isFlickering = win.flicker && Math.random() > 0.8;
                    if (!isFlickering) {
                        ctx.fillStyle = win.color;
                        // Invert Y for drawing from bottom logic
                        ctx.fillRect(drawX + win.x, h - this.h + win.y, win.w, win.h);
                    }
                });

            // Neon Signs (Glow effect)
            ctx.save();
            this.neonSigns.forEach(sign => {
                ctx.shadowBlur = 15;
                ctx.shadowColor = sign.color;
                ctx.fillStyle = sign.color;
                ctx.fillRect(drawX + sign.x, h - this.h + sign.y, sign.w, sign.h);
                
                // "Text" lines inside sign
                ctx.fillStyle = '#fff';
                ctx.shadowBlur = 0;
                for(let i=0; i<sign.h; i+=8) {
                    ctx.fillRect(drawX + sign.x + 4, h - this.h + sign.y + i + 2, sign.w - 8, 2);
                }
            });
            ctx.restore();
            }
        }
    }

    class Layer {
        constructor(speed, color, isFront) {
            this.speed = speed;
            this.color = color;
            this.isFront = isFront;
            this.buildings = [];
            this.scrollX = 0;
            this.totalWidth = 0;
            this.populate();
        }

        populate() {
            // Fill screen plus buffer
            while (this.totalWidth < w + 500) {
                this.addBuilding();
            }
        }

        addBuilding() {
            const b = new Building(this.totalWidth, 0, this.color, this.isFront);
            this.buildings.push(b);
            // Add random gap
            const gap = this.isFront ? random(-10, 0) : random(-5, 5); // Overlap front buildings slightly
            this.totalWidth += b.w + gap;
        }

        update() {
            this.scrollX += this.speed * CONFIG.speed;

            // Cleanup and generate
            const firstBuilding = this.buildings[0];
            if (firstBuilding.x + firstBuilding.w < this.scrollX - 100) {
                this.buildings.shift();
                this.addBuilding();
            }
        }

        draw() {
            this.buildings.forEach(b => b.draw(ctx, this.scrollX));
            
            // Floor/Fog for this layer
            ctx.fillStyle = this.color;
            ctx.fillRect(0, h - 10, w, 10);
        }
    }

    class TrafficSystem {
        constructor() {
            this.cars = [];
            this.timer = 0;
        }

        update() {
            this.timer++;
            // Spawn car
            if (this.timer > 30) { 
                if (Math.random() > 0.7) {
                    this.cars.push({
                        x: Math.random() > 0.5 ? -50 : w + 50,
                        y: random(h - 150, h - 20),
                        dir: 0, // set below
                        speed: random(4, 8),
                        color: randomChoice(CONFIG.colors.neon),
                        size: random(20, 40)
                    });
                    // Set direction based on spawn side
                    let c = this.cars[this.cars.length-1];
                    c.dir = c.x < 0 ? 1 : -1;
                }
                this.timer = 0;
            }

            // Move cars
            for (let i = this.cars.length - 1; i >= 0; i--) {
                let c = this.cars[i];
                c.x += c.speed * c.dir * CONFIG.speed;
                
                // Remove if off screen
                if ((c.dir === 1 && c.x > w + 100) || (c.dir === -1 && c.x < -100)) {
                    this.cars.splice(i, 1);
                }
            }
        }

        draw() {
            ctx.save();
            this.cars.forEach(c => {
                // Trail effect
                const grad = ctx.createLinearGradient(c.x, 0, c.x - (c.size * 3 * c.dir), 0);
                grad.addColorStop(0, c.color);
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                
                ctx.fillStyle = grad;
                ctx.fillRect(c.x - (c.dir === 1 ? c.size * 3 : 0), c.y, c.size * 3, 2);

                // Car body
                ctx.shadowBlur = 10;
                ctx.shadowColor = c.color;
                ctx.fillStyle = '#fff';
                ctx.fillRect(c.x, c.y, c.size, 4);
            });
            ctx.restore();
        }
    }

    class Rain {
        constructor() {
            this.drops = [];
        }
        
        update() {
            // Add new drops
            for(let i=0; i<5; i++) {
                this.drops.push({
                    x: Math.random() * w,
                    y: -20,
                    speed: random(10, 20),
                    len: random(10, 30)
                });
            }

            // Move
            for(let i=this.drops.length-1; i>=0; i--) {
                let d = this.drops[i];
                d.y += d.speed;
                d.x -= 1; // wind
                if (d.y > h) this.drops.splice(i, 1);
            }
        }

        draw() {
            ctx.strokeStyle = 'rgba(100, 100, 255, 0.2)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            this.drops.forEach(d => {
                ctx.moveTo(d.x, d.y);
                ctx.lineTo(d.x - 1, d.y + d.len);
            });
            ctx.stroke();
        }
    }

    // Global Objects
    let starfield, bg, layers = [], traffic, rain;

    function init() {
        w = window.innerWidth;
        h = window.innerHeight;
        canvas.width = w;
        canvas.height = h;

        starfield = new Starfield(150);
        bg = new Background();
        
        // Create layers (Speed, Color, IsFront)
        layers = [
            new Layer(0.5, CONFIG.colors.layer1, false),
            new Layer(1.5, CONFIG.colors.layer2, false),
            new Layer(3.5, CONFIG.colors.layer3, true)
        ];

        traffic = new TrafficSystem();
        rain = new Rain();
    }

    function animate() {
        frame++;
        
        // Update
        layers.forEach(l => l.update());
        traffic.update();
        rain.update();

        // Draw
        ctx.clearRect(0, 0, w, h);
        
        bg.draw(); // Sky & Sun
        starfield.draw(frame);

        // Layer 0 (Back)
        layers[0].draw();
        
        // Layer 1 (Mid)
        layers[1].draw();

        // Traffic behind front buildings
        traffic.draw();

        // Layer 2 (Front)
        layers[2].draw();
        
        // Atmosphere overlay (Vignette)
        const grad = ctx.createRadialGradient(w/2, h/2, h/2, w/2, h/2, w);
        grad.addColorStop(0, 'rgba(0,0,0,0)');
        grad.addColorStop(1, 'rgba(0,0,0,0.6)');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,w,h);

        rain.draw();

        animationId = requestAnimationFrame(animate);
    }

    // Resize Handling
    window.addEventListener('resize', () => {
        w = window.innerWidth;
        h = window.innerHeight;
        canvas.width = w;
        canvas.height = h;
    });

    init();
    animate();

})();
</script>
</body>
</html>
